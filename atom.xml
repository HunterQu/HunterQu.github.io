<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hunter&#39;s Blog</title>
  
  
  <link href="https://hntr.xyz/atom.xml" rel="self"/>
  
  <link href="https://hntr.xyz/"/>
  <updated>2020-10-01T13:57:40.915Z</updated>
  <id>https://hntr.xyz/</id>
  
  <author>
    <name>Hunter_H</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>珂朵莉树</title>
    <link href="https://hntr.xyz/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91.html"/>
    <id>https://hntr.xyz/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91.html</id>
    <published>2020-09-30T16:00:00.000Z</published>
    <updated>2020-10-01T13:57:40.915Z</updated>
    
    <content type="html"><![CDATA[<p>（<emp>珂朵莉最可爱了 珂朵莉树最不可爱了</emp><br>首先，珂朵莉树 一个十分暴力的算法，<wavy>仅限于大量的随机数据，否则时间复杂度起飞</wavy>，所以只要出题人想卡 就很容易GG</p><h3 id="珂朵莉"><a href="#珂朵莉" class="headerlink" title="珂朵莉"></a>珂朵莉</h3><p>出自《末日时在干什么？有没有空？可以来拯救吗？》的治愈番<del>（万物皆可致郁）</del><br>（快去看！出门左转樱x动漫！）<br><a href="https://zh.moegirl.org.cn/%E7%8F%82%E6%9C%B5%E8%8E%89%C2%B7%E8%AF%BA%E5%A1%94%C2%B7%E7%91%9F%E5%B0%BC%E6%AC%A7%E9%87%8C%E6%96%AF">珂朵莉的萌娘百科！</a><br><img src="https://cdn.jsdelivr.net/gh/hunterqu/cdn@master/blog/img/posts/kdl/kdl.png"></p><hr><p>回归正题</p><psw>到底珂朵莉可爱在哪里</psw>珂朵莉树是什么<h3 id="珂朵莉树"><a href="#珂朵莉树" class="headerlink" title="珂朵莉树"></a>珂朵莉树</h3><p>又称 ODT（old driver tree）老司机树<br>最初出现在 <a href="https://www.luogu.com.cn/problem/CF896C">CF896C</a></p><p>用于实现序列操作 包括了一下几种：</p><ol><li>将$[l, r]$区间所有数加上$x$</li><li>将$[l, r]$区间所有数改为$x$</li><li>求出$[l, r]$区间内的第$k$大的数</li><li>求出$[l, r]$区间每个数字的$x$次方的和模$y$的值 即$(sum^r_{i=l}a^x_i)\ mod\  y$<br>数据随机生成</li></ol><p>那么珂朵莉树是如何实现的呢？</p><p><strong>把值相同的区间合并成一个结点保存在 set 里面。</strong></p><p>显然 这样做如果退化成一个数变成一个区间就裂开了 所以这很需要数据随机（将某一段改为同一个值这种操作）<br>所以 珂朵莉树可以用来骗分。只要是有区间赋值操作的数据结构题都可以用来骗分。在数据随机的情况下一般效率较高   <strong>有可能被精心构造的特殊数据卡到超时。</strong>（lxl直呼内行）</p><h3 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">mutable</span> LL v;</span><br><span class="line">    Node (<span class="keyword">int</span> L, <span class="keyword">int</span> R, LL V): l(L), r(R), v(V) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123; <span class="comment">//这一个为了后续set的insert方便 可以不写 写了这个可以  s.insert(Node(l, r, x))之类的 等价于 s.insert((Node)&#123;l, r, x&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="assign区间赋值"><a href="#assign区间赋值" class="headerlink" title="assign区间赋值"></a>assign区间赋值</h3><p>这是保证珂朵莉树在<strong>随机</strong>数据下优秀的时间复杂度的根本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ass_ign</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter itr = split(r + <span class="number">1</span>), itl = split(l);</span><br><span class="line">    kdl.erase(itl, itr);</span><br><span class="line">    kdl.insert(Node(l, r, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆开区间<br>将$[l, r]$区间所有都区间删掉<br>变成一个插入<code>set</code></p><h3 id="split拆分区间"><a href="#split拆分区间" class="headerlink" title="split拆分区间"></a>split拆分区间</h3><p>珂朵莉树如何区间操作呢<br>把你想操作的区间从整个里面拆出来 然后暴力求解（没错）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set<span class="meta-string">&lt;Node &gt;::iterator //打起来方便  后续不再写入代码</span></span></span><br><span class="line"><span class="function">iter <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter it = kdl.lower_bound(Node(pos, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != kdl.end() &amp;&amp; it-&gt;l == pos) <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="keyword">int</span> L = it-&gt;l, R = it-&gt;r;</span><br><span class="line">    LL V = it-&gt;v;</span><br><span class="line">    kdl.erase(it);</span><br><span class="line">    kdl.insert(Node(L, pos<span class="number">-1</span>, V));</span><br><span class="line">    <span class="keyword">return</span> kdl.insert(Node(pos, R, V)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>split函数可以将区间从pos位置断开（pos被留在右边的区间） 并返回右边这个区间在set中的迭代器</p><p>于是  各种暴力的求解就来了</p><h3 id="暴力の第k大"><a href="#暴力の第k大" class="headerlink" title="暴力の第k大"></a>暴力の第k大</h3><p>思路：拆出来$[l, r]$区间   排个序（没错）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;LL, <span class="keyword">int</span>&gt; &gt; vp;<span class="comment">//临时存放拆出来的节点</span></span><br><span class="line">    iter itr = split(r + <span class="number">1</span>), itl = split(l);</span><br><span class="line">    vp.clear();</span><br><span class="line">    <span class="keyword">for</span> (; itl != itr; ++itl)</span><br><span class="line">        vp.push_back(<span class="built_in">pair</span>&lt;LL, <span class="keyword">int</span>&gt;(itl-&gt;v, itl-&gt;r - itl-&gt;l + <span class="number">1</span>));</span><br><span class="line">    sort(vp.begin(), vp.end());<span class="comment">//暴力+++++</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;LL, <span class="keyword">int</span>&gt; &gt;::iterator i = vp.begin(); i != vp.end(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        k -= i-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> i-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暴力の求和"><a href="#暴力の求和" class="headerlink" title="暴力の求和"></a>暴力の求和</h3><p>简单明了 直接拆开for循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter itr = split(r + <span class="number">1</span>), itl = split(l);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; itl != itr; ++itl)</span><br><span class="line">        ans = (ans + (LL)(itl-&gt;r - itl-&gt;l + <span class="number">1</span>) * <span class="built_in">pow</span>(itl-&gt;v, LL(x), LL(mod)) ) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在不是随机数据的绝大多数情况下<br>珂朵莉树只能骗到一些分数  很可能被卡<br>所以扎扎实实去磨线段树（虽然骗分打一打这个还是很香的</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>本题目的完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set<span class="meta-string">&lt;Node &gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD7 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD9 = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">mutable</span> LL v;</span><br><span class="line">    Node (<span class="keyword">int</span> L, <span class="keyword">int</span> R, LL V): l(L), r(R), v(V) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;Node &gt; kdl;</span><br><span class="line">LL n, m, seed, vmax, a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">iter <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter it = kdl.lower_bound(Node(pos, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != kdl.end() &amp;&amp; it-&gt;l == pos) <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="keyword">int</span> L = it-&gt;l, R = it-&gt;r;</span><br><span class="line">    LL V = it-&gt;v;</span><br><span class="line">    kdl.erase(it);</span><br><span class="line">    kdl.insert(Node(L, pos<span class="number">-1</span>, V));</span><br><span class="line">    <span class="keyword">return</span> kdl.insert(Node(pos, R, V)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, LL s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter itr = split(r + <span class="number">1</span>), itl = split(l);</span><br><span class="line">    <span class="keyword">for</span> (; itl != itr; ++itl) itl-&gt;v += s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ass_ign</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter itr = split(r + <span class="number">1</span>), itl = split(l);</span><br><span class="line">    kdl.erase(itl, itr);</span><br><span class="line">    kdl.insert(Node(l, r, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;LL, <span class="keyword">int</span>&gt; &gt; vp;</span><br><span class="line">    iter itr = split(r + <span class="number">1</span>), itl = split(l);</span><br><span class="line">    vp.clear();</span><br><span class="line">    <span class="keyword">for</span> (; itl != itr; ++itl)</span><br><span class="line">        vp.push_back(<span class="built_in">pair</span>&lt;LL, <span class="keyword">int</span>&gt;(itl-&gt;v, itl-&gt;r - itl-&gt;l + <span class="number">1</span>));</span><br><span class="line">    sort(vp.begin(), vp.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;LL, <span class="keyword">int</span>&gt; &gt;::iterator i = vp.begin(); i != vp.end(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        k -= i-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> i-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL a, LL b, LL mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    LL ans = a % mod;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = res * ans % mod;</span><br><span class="line">        ans = ans * ans % mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter itr = split(r + <span class="number">1</span>), itl = split(l);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; itl != itr; ++itl)</span><br><span class="line">        ans = (ans + (LL)(itl-&gt;r - itl-&gt;l + <span class="number">1</span>) * <span class="built_in">pow</span>(itl-&gt;v, LL(x), LL(mod)) ) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">rnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ret = seed;</span><br><span class="line">    seed = (seed * <span class="number">7</span> + <span class="number">13</span>) % MOD7;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld %lld&quot;</span>, &amp;n, &amp;m, &amp;seed, &amp;vmax);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = (rnd() % vmax) + <span class="number">1</span>;</span><br><span class="line">        kdl.insert(Node(i,i,a[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//kdl.insert(Node(n+1, n+1, 0));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="keyword">int</span>(rnd() % <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="keyword">int</span>(rnd() % n) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="keyword">int</span>(rnd() % n) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) swap(l, r);</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">            x = <span class="keyword">int</span>(rnd() % (r-l+<span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="keyword">int</span>(rnd() % vmax) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">4</span>)</span><br><span class="line">            y = <span class="keyword">int</span>(rnd() % vmax) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            add(l, r, LL(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">            ass_ign(l, r, LL(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Rank(l, r, x));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum(l, r, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（&lt;emp&gt;珂朵莉最可爱了 珂朵莉树最不可爱了&lt;/emp&gt;&lt;br&gt;首先，珂朵莉树 一个十分暴力的算法，&lt;wavy&gt;仅限于大量的随机数据，否则时间复杂度起飞&lt;/wavy&gt;，所以只要出题人想卡 就很容易GG&lt;/p&gt;
&lt;h3 id=&quot;珂朵莉&quot;&gt;&lt;a href=&quot;#珂朵莉&quot; cla</summary>
      
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="树" scheme="https://hntr.xyz/tags/%E6%A0%91/"/>
    
    <category term="珂朵莉" scheme="https://hntr.xyz/tags/%E7%8F%82%E6%9C%B5%E8%8E%89/"/>
    
  </entry>
  
  <entry>
    <title>P2709的一枚题解</title>
    <link href="https://hntr.xyz/P2709.html"/>
    <id>https://hntr.xyz/P2709.html</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-16T06:11:50.106Z</updated>
    
    <content type="html"><![CDATA[<p>有一个长为$a$, 值域为$[1,k]$的序列</p><p>对于每个询问区间$[l,r]$</p><p>求</p><p>$$<br>\sum^k_{i=1}{c^2_i}<br>$$</p><p>其中$c_i$表示数字$i$在$[l,r]$中出现的次数</p><p>莫队是由前国家队队长莫涛发明的</p><p>莫队算法的精髓就是通过合理地对询问排序，然后以较优的顺序暴力回答每个询问。处理完一个询问后，可以使用它的信息得到下一个询问区间的答案。（两个边界瞎跳）</p><p>考虑这个问题：对于上面这道题，我们知道区间$[1,5]$的答案，就可以求出$[2,6]$每个数的数量</p><p>莫队提供了这样一个排序方案：将原序列以$\sqrt{n}$为一块进行分块（分块的大小也珂以调整），排序第一关键字是询问的左端点所在块的编号，第二关键字是询问的右端点本身的位置，都是升序。然后我们用上面提到的“移动当前区间左右端点”的方法，按顺序求每个询问区间的答案，移动每一个询问区间左右端点可以求出下一个区间的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pos[a.l] == pos[b.l] ? a.r &lt; b.r : pos[a.l] &lt; pos[b.l];</span><br></pre></td></tr></table></figure><p>这道题目只要分块排序亿下之后</p><a id="more"></a><p>就可以<del>暴力</del>解决了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &lt; l) add(--l);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &gt; r) add(++r);</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &gt; l) sub(l++);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &lt; r) sub(r--);</span><br><span class="line">        ans[q[i].k] = res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><del>莫队经典片段</del></p><p>更新代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[a[x]]++; </span><br><span class="line">    res = res - (cnt[a[x]] - <span class="number">1</span>) * (cnt[a[x]] - <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[a[x]]--; </span><br><span class="line">    res = res - (cnt[a[x]] + <span class="number">1</span>) * (cnt[a[x]] + <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度大约是 $O(n\sqrt{n})$</p><p>全部代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], cnt[MAXN], pos[MAXN], n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[MAXN], res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">&#125;q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cnt[a[x]]++; res = res - (cnt[a[x]] - <span class="number">1</span>) * (cnt[a[x]] - <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; <span class="keyword">return</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;cnt[a[x]]--; res = res - (cnt[a[x]] + <span class="number">1</span>) * (cnt[a[x]] + <span class="number">1</span>) + cnt[a[x]] * cnt[a[x]]; <span class="keyword">return</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Q a, Q b)</span></span>&#123;<span class="keyword">return</span> pos[a.l] == pos[b.l] ? a.r &lt; b.r : pos[a.l] &lt; pos[b.l];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">        freopen(<span class="string">&quot;in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">&quot;out.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> siz = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        pos[i] = i / siz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">        q[i].k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &lt; l) add(--l);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &gt; r) add(++r);</span><br><span class="line">        <span class="keyword">while</span> (q[i].l &gt; l) sub(l++);</span><br><span class="line">        <span class="keyword">while</span> (q[i].r &lt; r) sub(r--);</span><br><span class="line">        ans[q[i].k] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有一个长为$a$, 值域为$[1,k]$的序列&lt;/p&gt;
&lt;p&gt;对于每个询问区间$[l,r]$&lt;/p&gt;
&lt;p&gt;求&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\sum^k_{i=1}{c^2_i}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中$c_i$表示数字$i$在$[l,r]$中出现的次数&lt;/p&gt;
&lt;p&gt;莫队是由前国家队队长莫涛发明的&lt;/p&gt;
&lt;p&gt;莫队算法的精髓就是通过合理地对询问排序，然后以较优的顺序暴力回答每个询问。处理完一个询问后，可以使用它的信息得到下一个询问区间的答案。（两个边界瞎跳）&lt;/p&gt;
&lt;p&gt;考虑这个问题：对于上面这道题，我们知道区间$[1,5]$的答案，就可以求出$[2,6]$每个数的数量&lt;/p&gt;
&lt;p&gt;莫队提供了这样一个排序方案：将原序列以$\sqrt{n}$为一块进行分块（分块的大小也珂以调整），排序第一关键字是询问的左端点所在块的编号，第二关键字是询问的右端点本身的位置，都是升序。然后我们用上面提到的“移动当前区间左右端点”的方法，按顺序求每个询问区间的答案，移动每一个询问区间左右端点可以求出下一个区间的答案。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; pos[a.l] == pos[b.l] ? a.r &amp;lt; b.r : pos[a.l] &amp;lt; pos[b.l];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这道题目只要分块排序亿下之后&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="莫队" scheme="https://hntr.xyz/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>题目题解-开车旅行</title>
    <link href="https://hntr.xyz/P1081-%E5%80%8D%E5%A2%9E.html"/>
    <id>https://hntr.xyz/P1081-%E5%80%8D%E5%A2%9E.html</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2020-08-16T06:10:08.355Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1081">P1081</a></p><h3 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h3><p>有一排高低不同的城市  <strong>城市距离=高度差</strong></p><p>A和B自左向右开车旅行（出发点可以变）</p><p>A、B的开车风格：</p><blockquote><p>1.A会前往右边距他<strong>第二近</strong>的城市<br>2.B会前往右边<strong>最近</strong>的城市<br>3.A和B开过的<strong>总里程</strong>不超过$X$</p></blockquote><p><strong>询问:</strong></p><p>1.给定一个$X$ 求出从哪个城市出发  $A$的路程/$B$的路程  最大</p><p>2.给定$X_i$和出发城市$S_i$ 求$A$和$B$分别开的距离数</p><h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><p>在没有修改的<code>RMQ</code>问题(区间最值问题) 基于<strong>倍增</strong>的ST表可以做到$O(1)$查询和$O(nlogn)$预处理</p><p>拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的)</p><p>那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值</p><p>比如</p><a id="more"></a><p><img src="https://hntr.xyz/img/st/transfer.jpg" alt="transfer"></p><p>$$<br>f[i][j] = \max{f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]}<br>$$</p><p>上面就是一般倍增用来求最大值时候的转移式(没什么用不用看</p><p>另一个倍增的常见应用就是$LCA$</p><p>通过倍增的思想向上跳</p><h3 id="那么"><a href="#那么" class="headerlink" title="那么"></a>那么</h3><p>这道题目</p><p>我们可以利用倍增向右跳</p><p>但是我们要先处理出$f[i][0]$</p><p>也就是从任意一个城市开始 走一步到达的城市</p><p>首先就要处理出对于到达每一个城市$a_i$   $A$和$B$的下一步会去哪里</p><p>这一步可以用一个双向链表 开始的时候将城市从低到高排序并且相邻的相连</p><p>就像这个</p><p><img src="https://i.loli.net/2020/08/08/4QHkoeWvg1d2JtL.png" alt="image.png"></p><p>排序完之后的顺序是  3 1 2 4</p><p>每一个点都与旁边相连</p><p>之后从原来顺序开始处理 不断选出A和B的选择然后删除这个节点 就可以处理完 <code>na</code>和<code>nb</code>数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> d[j].v-d[l].v&lt;=d[r].v-d[j].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        j = p[i]; l = d[j].l; r = d[j].r;</span><br><span class="line">        <span class="keyword">if</span> (left()) </span><br><span class="line">            nb[i] = d[l].i, na[i] = pd(d[l].l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nb[i] = d[r].i, na[i] = pd(l, d[r].r);</span><br><span class="line">        <span class="keyword">if</span> (l) d[l].r = r;</span><br><span class="line">        <span class="keyword">if</span> (r) d[r].l = l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>$na[i]$表示在$i$号城市时，$A$的下一个城市</p><p>之后就可以将A开一天B开一天当作一步</p><p>用倍增来初始化 $f[i][j]$从$i$号城市开始 走$2^j$大步后到达的城市</p><p>$sta[i][j]$表示从$i$号城市开始 走$2^j$大步后 A走过的路程（是一个累计量</p><p>$stb$数组同理</p><p>这样我们就可以用倍增枚举和找到符合要求的答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getab</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    a = b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[p][i] &amp;&amp; (<span class="keyword">long</span> <span class="keyword">long</span>)(a + b + stA[p][i]+stB[p][i]) &lt;= x) &#123;</span><br><span class="line">            a += stA[p][i];</span><br><span class="line">            b += stB[p][i];</span><br><span class="line">            p = f[p][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (na[p] &amp;&amp; a + b + stA[p][<span class="number">0</span>] &lt;= x) a += stA[p][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//因为f表示的是一大步（ab各一步） 所以可能A还可以走一步</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, j;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, v, l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; A.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;d[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[<span class="number">100005</span>], p[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> stA[<span class="number">100005</span>][<span class="number">21</span>], stB[<span class="number">100005</span>][<span class="number">21</span>], f[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> na[<span class="number">100005</span>], nb[<span class="number">100005</span>], a, b, ans = n;</span><br><span class="line"><span class="keyword">double</span> minn = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> d[j].v-d[l].v&lt;=d[r].v-d[j].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> d[b].i;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> d[a].i;</span><br><span class="line">    <span class="keyword">if</span> (d[j].v-d[a].v &lt;= d[b].v-d[j].v) <span class="keyword">return</span> d[a].i;</span><br><span class="line">    <span class="keyword">return</span> d[b].i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_st</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">19</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f[i][j] = f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//位置</span></span><br><span class="line">            stA[i][j] = stA[i][j<span class="number">-1</span>] + stA[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            stB[i][j] = stB[i][j<span class="number">-1</span>] + stB[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getab</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    a = b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[p][i] &amp;&amp; (<span class="keyword">long</span> <span class="keyword">long</span>)(a + b + stA[p][i]+stB[p][i]) &lt;= x) &#123;</span><br><span class="line">            a += stA[p][i];</span><br><span class="line">            b += stB[p][i];</span><br><span class="line">            p = f[p][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (na[p] &amp;&amp; a + b + stA[p][<span class="number">0</span>] &lt;= x) a += stA[p][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;out.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i].v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        d[i].i = i;</span><br><span class="line"></span><br><span class="line">    sort(d + <span class="number">1</span>, d + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p[d[i].i] = i;<span class="comment">//记录原本的顺序 p[i]存放了原来在i位置的城市排序完的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        d[i].l = i<span class="number">-1</span>, d[i].r = i+<span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>].l = d[n].r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        j = p[i]; l = d[j].l; r = d[j].r;</span><br><span class="line">        <span class="keyword">if</span> (left()) </span><br><span class="line">            nb[i] = d[l].i, na[i] = pd(d[l].l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nb[i] = d[r].i, na[i] = pd(l, d[r].r);</span><br><span class="line">        <span class="keyword">if</span> (l) d[l].r = r;</span><br><span class="line">        <span class="keyword">if</span> (r) d[r].l = l;</span><br><span class="line">    &#125;<span class="comment">//na, nb是对于原来的第i号城市 A和B的下一个目的地</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, na[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nb[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = nb[na[i]];</span><br><span class="line">        <span class="comment">//A和B一起倍增</span></span><br><span class="line">        stA[i][<span class="number">0</span>] = <span class="built_in">abs</span>(d[p[i]].v - d[p[na[i]]].v);</span><br><span class="line">        stB[i][<span class="number">0</span>] = <span class="built_in">abs</span>(d[p[na[i]]].v - d[p[f[i][<span class="number">0</span>]]].v);</span><br><span class="line">        <span class="comment">//A和B  在A一步B一部之后 分别移动的的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    make_st();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>, &amp;x, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        getab(x, i);</span><br><span class="line">        <span class="keyword">if</span> (b &amp;&amp; <span class="number">1.0</span>*a/b &lt; minn) &#123;</span><br><span class="line">            minn = <span class="number">1.0</span>*a/b;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;j, &amp;x);</span><br><span class="line">        getab(x, j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1081&quot;&gt;P1081&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目简述&quot;&gt;&lt;a href=&quot;#题目简述&quot; class=&quot;headerlink&quot; title=&quot;题目简述&quot;&gt;&lt;/a&gt;题目简述&lt;/h3&gt;&lt;p&gt;有一排高低不同的城市  &lt;strong&gt;城市距离=高度差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A和B自左向右开车旅行（出发点可以变）&lt;/p&gt;
&lt;p&gt;A、B的开车风格：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.A会前往右边距他&lt;strong&gt;第二近&lt;/strong&gt;的城市&lt;br&gt;2.B会前往右边&lt;strong&gt;最近&lt;/strong&gt;的城市&lt;br&gt;3.A和B开过的&lt;strong&gt;总里程&lt;/strong&gt;不超过$X$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;询问:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.给定一个$X$ 求出从哪个城市出发  $A$的路程/$B$的路程  最大&lt;/p&gt;
&lt;p&gt;2.给定$X_i$和出发城市$S_i$ 求$A$和$B$分别开的距离数&lt;/p&gt;
&lt;h3 id=&quot;倍增&quot;&gt;&lt;a href=&quot;#倍增&quot; class=&quot;headerlink&quot; title=&quot;倍增&quot;&gt;&lt;/a&gt;倍增&lt;/h3&gt;&lt;p&gt;在没有修改的&lt;code&gt;RMQ&lt;/code&gt;问题(区间最值问题) 基于&lt;strong&gt;倍增&lt;/strong&gt;的ST表可以做到$O(1)$查询和$O(nlogn)$预处理&lt;/p&gt;
&lt;p&gt;拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的)&lt;/p&gt;
&lt;p&gt;那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="倍增" scheme="https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="双向链表" scheme="https://hntr.xyz/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>服务站-无权限题目</title>
    <link href="https://hntr.xyz/%E6%9C%8D%E5%8A%A1%E7%AB%99.html"/>
    <id>https://hntr.xyz/%E6%9C%8D%E5%8A%A1%E7%AB%99.html</id>
    <published>2020-08-06T16:00:00.000Z</published>
    <updated>2020-08-15T15:56:01.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>渡渡鸟国的每位国民都有一个长度为 $n$ 的身份证号，身份证号的每一位为 $[1,k]$ 内的一个整数。渡渡鸟国现在要设立若干个服务站，每个服务站有一个长度为 $2$ 的编号，每一位也是 $[1,k]$ 内的一个整数。</p><p>对于一只渡渡鸟，设其身份证号为 $s$，其中 $s$ 是一个长度为 $n$ 的字符串。对于一个服务站，设其编号为 $t$，其中 $t$ 是一个长度为 $2$ 的字符串。当且仅当 $t$ 是 $s$ 的子序列时，这只渡渡鸟可以被这个服务站服务。比如 $s=123,t=13$ 时，渡渡鸟可以被服务；而$s=123,t=31$ 时，渡渡鸟不能被服务。</p><p>渡渡鸟国王希望建设一些服务站，使得任意一只渡渡鸟都可以被至少一个服务站服务。它想知道最少需要建造多少个服务站。</p><p>通过并查集 首先最后要分成（k-1）组 然后求步数即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;渡渡鸟国的每位国民都有一个长度为 $n$ 的身份证号，身份证号的每一位为 $[1,k]$ 内的一个整数。渡渡鸟国现在要设立若</summary>
      
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="数学" scheme="https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="并查集" scheme="https://hntr.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>P5023</title>
    <link href="https://hntr.xyz/P5023.html"/>
    <id>https://hntr.xyz/P5023.html</id>
    <published>2020-06-13T12:30:00.000Z</published>
    <updated>2020-07-20T02:04:23.991Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述详见 <a href="https://www.luogu.com.cn/problem/P5023">luogu</a></p><p>题目可以说是非常的长，但是读懂之后概括一下大概就是找到一种填写01的方式，使得任意取两条合法（从$(1,1)$向右向下走到右下角）的路径， 右上路径经过的数字连接成的字符串字典序小。</p><p>然后就是漫长的手模＋找规律</p><p>在模拟$3*3$时，第一次模拟出来的结果非常amazing，竟然有144种<br>在我的理解中，我认为只要是左下-右上走向的线上的数字不递增就可以了<br>如图<br><img src="https://hntr.xyz/img/5023/wrong.png"></p><p>如图$4 \times 4 \times 3 \times 3=144$</p><p>但是显然 这是错误的</p><p>正确解法：</p><a id="more"></a><p>对于上面我的那种天真的想法，这就是一个反例<br><img src="https://hntr.xyz/img/5023/1.png"></p><p>这种交叉的情况下，就要分类讨论</p><p>1.当$n=1$时：</p><p>很明显，答案是$m^{2}$ 这里就不多讨论了。</p><p>2.当$n&gt;1$ 且 $n=m$时</p><p>（$n = 3$）</p><p><img src="https://hntr.xyz/img/5023/2.png"></p><p>图中橙色数字为这一平行线的可能数量， 红色为填入的数字， 蓝色为平行线， 蓝色区域填入的数字必须相等，否则会导致交叉情况出错</p><p>（$n = 4$）</p><p><img src="https://hntr.xyz/img/5023/3.png"></p><p>……</p><p>会发现</p><p>$$<br>ans(3,3) = 2^2 \times 3 \times 4 + 2^4 \times 4 \<br>ans(4,4) = 2^5 \times 5+2^4\times3\times5+2^5\times4^2\<br>ans(5,5) = 2^7\times4\times5+2^5\times3\times5+2^6\times4^3<br>$$</p><p>可得</p><p>$$<br>ans (n,n) = 2^3\cdot ans(n-1, n-1)-5\times2^n<br>$$</p><p>3.当 $n&gt;1$ 且 $n+1=m$时</p><p>$$<br>ans(n,n+1)=3\cdot ans(n,n) - 3\times 2^n<br>$$</p><p>4.当$n&gt;1$且$n+1&lt;m$</p><p>$$<br>ans(n,i)=3\cdot ans(n,i−1)<br>$$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mod = <span class="number">1000000007</span>, f[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            ans = ans * <span class="number">2</span> % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) ans = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) ans = <span class="number">112</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span>) ans = <span class="number">912</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans = <span class="number">912</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i++)</span><br><span class="line">            ans = ans * <span class="number">8</span> - <span class="number">5</span> * f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n + <span class="number">1</span> &amp;&amp; n &gt; <span class="number">3</span>)</span><br><span class="line">        ans = ans * <span class="number">3</span> - <span class="number">3</span> * f[n];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (m == n + <span class="number">1</span>) ans = ans *<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &gt; n + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">3</span>)</span><br><span class="line">            ans = ans *<span class="number">3</span> - <span class="number">3</span> * f[n];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = ans *<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">            ans = ans * <span class="number">3</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（敲完人没了，这比T3还恶心</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目描述详见 &lt;a href=&quot;https://www.luogu.com.cn/problem/P5023&quot;&gt;luogu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目可以说是非常的长，但是读懂之后概括一下大概就是找到一种填写01的方式，使得任意取两条合法（从$(1,1)$向右向下走到右下角）的路径， 右上路径经过的数字连接成的字符串字典序小。&lt;/p&gt;
&lt;p&gt;然后就是漫长的手模＋找规律&lt;/p&gt;
&lt;p&gt;在模拟$3*3$时，第一次模拟出来的结果非常amazing，竟然有144种&lt;br&gt;在我的理解中，我认为只要是左下-右上走向的线上的数字不递增就可以了&lt;br&gt;如图&lt;br&gt;&lt;img src=&quot;https://hntr.xyz/img/5023/wrong.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图$4 \times 4 \times 3 \times 3=144$&lt;/p&gt;
&lt;p&gt;但是显然 这是错误的&lt;/p&gt;
&lt;p&gt;正确解法：&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
    <category term="DP" scheme="https://hntr.xyz/tags/DP/"/>
    
    <category term="shu数论" scheme="https://hntr.xyz/tags/shu%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>P1969</title>
    <link href="https://hntr.xyz/P1969.html"/>
    <id>https://hntr.xyz/P1969.html</id>
    <published>2020-05-24T07:40:19.000Z</published>
    <updated>2020-05-24T07:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述<br>春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为$1$的积木组成，第i块积木的最终高度需要是$h_i$<br>在搭建开始之前，没有任何积木（可以看成nn块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l,r]$，然后将第第$L$块到第 $R$ 块之间（含第$L$ 块和第 $R$块）所有积木的高度分别增加$1$。</p><p>小MM是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。</p><a id="more"></a><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; last)</span><br><span class="line">            ans += (a - last);</span><br><span class="line">        last = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>↓ 来自 <a href="https://www.luogu.com.cn/blog/ArthasMenethil/solution-p1969">阿尔萨斯’s题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span><span class="comment">//快速读入可有可无</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();</span><br><span class="line">    ll s=<span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)t*=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s*t;</span><br><span class="line">&#125;</span><br><span class="line">ll ans[<span class="number">400004</span>],a[<span class="number">100001</span>],n,answer=<span class="number">0</span>;<span class="comment">//a是每个地方需要搭的高</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ls</span><span class="params">(ll x)</span><span class="comment">//开始线段树，这是返回左子树的节点值，会线段树的不用看了，线段树打发很多</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rs</span><span class="params">(ll x)</span><span class="comment">//右子树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll l,ll r,ll s)</span><span class="comment">//递归建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="comment">//如果触底就返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[s]=l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,ls(s));<span class="comment">//二分建树</span></span><br><span class="line">    build(mid+<span class="number">1</span>,r,rs(s));</span><br><span class="line">    ll s1,s2;</span><br><span class="line">    s1=a[ans[ls(s)]];<span class="comment">//列出左右子树中最低处的高</span></span><br><span class="line">    s2=a[ans[rs(s)]];</span><br><span class="line">    <span class="keyword">if</span>(s1&lt;s2)ans[s]=ans[ls(s)];<span class="comment">//返回最低处</span></span><br><span class="line">    <span class="keyword">else</span> ans[s]=ans[rs(s)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll s,ll l,ll r,ll xl,ll xr)</span><span class="comment">//注意返回值为位置 ，高度要用a[find(?????)]表示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xl&lt;=l&amp;&amp;r&lt;=xr)<span class="keyword">return</span> ans[s];<span class="comment">//如果这个节点应该查询，也就是被查询的左右区间包含，就返回</span></span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>,lo,lo2,k;</span><br><span class="line">    <span class="keyword">if</span>(xl&lt;=mid)<span class="comment">//没错就是这里！一定要注意如果该节点左子树不用查询就直接返回右子树的值，否则再比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        lo=find(ls(s),l,mid,xl,xr);<span class="comment">//lo就是左子树中最低点的位置</span></span><br><span class="line">        k=lo;<span class="comment">//用于比较，记录最低点</span></span><br><span class="line">        <span class="keyword">if</span>(mid&lt;xr)</span><br><span class="line">        &#123;</span><br><span class="line">            lo2=find(rs(s),mid+<span class="number">1</span>,r,xl,xr);<span class="comment">//lo2是右子树最低点位置</span></span><br><span class="line">            <span class="keyword">if</span>(a[lo2]&lt;a[lo])k=lo2;<span class="comment">//比较</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果没有左子树就直接查询右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        lo=find(rs(s),mid+<span class="number">1</span>,r,xl,xr);</span><br><span class="line">        k=lo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ll l,ll r,ll h)</span><span class="comment">//h是之前的高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;<span class="comment">//奇怪的判断，分别判断这个区间是否存在，是否越界*2</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;n)<span class="keyword">return</span>;</span><br><span class="line">    ll lo=find(<span class="number">1</span>,<span class="number">1</span>,n,l,r),height;</span><br><span class="line">    height=a[lo];</span><br><span class="line">    answer+=height-h;<span class="comment">//answer加上（当前高度-之前的高度）</span></span><br><span class="line">    f(l,lo<span class="number">-1</span>,height);<span class="comment">//二分</span></span><br><span class="line">    f(lo+<span class="number">1</span>,r,height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)a[i]=read();</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;answer;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目描述&lt;br&gt;春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为$1$的积木组成，第i块积木的最终高度需要是$h_i$&lt;br&gt;在搭建开始之前，没有任何积木（可以看成nn块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l,r]$，然后将第第$L$块到第 $R$ 块之间（含第$L$ 块和第 $R$块）所有积木的高度分别增加$1$。&lt;/p&gt;
&lt;p&gt;小MM是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="贪心" scheme="https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>P5020</title>
    <link href="https://hntr.xyz/P5020.html"/>
    <id>https://hntr.xyz/P5020.html</id>
    <published>2020-05-24T07:15:18.000Z</published>
    <updated>2020-05-24T07:44:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5020">题目链接</a></p><p>详情见愿题目</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], maxx, ans, vis[<span class="number">25000</span>], f[<span class="number">25000</span>], t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        maxx = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">25000</span>; ++i)</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            maxx = max(maxx, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);<span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[i]]) <span class="comment">//标记过了，不选</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ans++; vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = a[i]; k &lt;= maxx; ++k) <span class="comment">//线性筛数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[k-a[i]])</span><br><span class="line">                    vis[k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5020&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详情见愿题目&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="贪心" scheme="https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
    <category term="DP" scheme="https://hntr.xyz/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>P3951</title>
    <link href="https://hntr.xyz/P3951.html"/>
    <id>https://hntr.xyz/P3951.html</id>
    <published>2020-05-10T08:04:39.000Z</published>
    <updated>2020-05-10T08:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3951">题目链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。</p><a id="more"></a><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>两个正整数 $a$ 和 $b$，它们之间用一个空格隔开，表示小凯中金币的面值。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个正整数 $N$，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>不妨设 $a&lt;b$</p><p>假设答案为 $x$</p><p>若</p><p>$x \equiv ma \pmod b (1 \leq m \leq b - 1)$</p><p>即</p><p>$x = ma + nb (1 \leq m \leq b - 1)$</p><p>显然当 $n \geq 0$时 $x$ 可以用 $a, b$表示出来，不合题意。</p><p>因此当 $n = -1$时 $x$ 取得最大值，此时 $x = ma - b$</p><p>显然当 $m$ 取得最大值 $b - 1$时 $x$ 最大，此时 $x = (b - 1)a - b = ab - a - b$</p><p>因此$ a, b$所表示不出的最大的数是 $ab - a - b$</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a * b - a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3951&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="数学" scheme="https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>P3952-时间复杂度</title>
    <link href="https://hntr.xyz/P3952.html"/>
    <id>https://hntr.xyz/P3952.html</id>
    <published>2020-05-10T05:50:00.000Z</published>
    <updated>2020-05-10T08:06:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3952">题目链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。</p><a id="more"></a><p>原题请至luogu查看</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="keyword">int</span> c, d, e, f[<span class="number">27</span>], g[<span class="number">27</span>], h, k, l[<span class="number">100</span>], m, n, o, T;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c是有几个句子，d是题目给的复杂度是多少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//e是当前在几重循环，f[]是判断变量是否使用过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//g[]是存下每个循环的变量，h是当前复杂度是多少(与e不同)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//k是判断下面程序是否进行，l[]是存下哪几个循环加了复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m是当前最大复杂度，n是存下k=1时的循环数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//T是数据组数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化 很重要</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = <span class="number">0</span>; d = <span class="number">0</span>; m = <span class="number">0</span>; n = <span class="number">0</span>; e = <span class="number">0</span>; h = <span class="number">0</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0</span>, <span class="keyword">sizeof</span>(l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--) </span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            a = b, <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">        &#125; <span class="keyword">while</span> (b[<span class="number">0</span>] != <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len_a = a.length();</span><br><span class="line">        <span class="keyword">int</span> len_b = b.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_a; i++)</span><br><span class="line">            c = c * <span class="number">10</span> + a[i] - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; len_b - <span class="number">1</span>; i++)</span><br><span class="line">            d = d * <span class="number">10</span> + b[i] - <span class="number">48</span>; <span class="comment">//取出题目给的时间复杂度 O(1)不影响 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c--;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;<span class="comment">//读入F 或 E ,句子数-1</span></span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                e++; <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">                <span class="keyword">if</span> (f[a[<span class="number">0</span>] - <span class="number">96</span>]) e = <span class="number">-1</span>;<span class="comment">//如果被用过，标记ERR</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//反之存起来并标记</span></span><br><span class="line"></span><br><span class="line">                    f[a[<span class="number">0</span>] - <span class="number">96</span>] = <span class="number">1</span>, g[e] = a[<span class="number">0</span>] - <span class="number">96</span>;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span>&amp;&amp;b[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;k == <span class="number">0</span>)</span><br><span class="line">                    h++, l[e] = <span class="number">1</span>;<span class="comment">//如果a是数字，b是n，而且可以运行，那么当前复杂度+1</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span> (((a.length() == b.length() &amp;&amp; a &gt; b) || (a.length() &gt; b.length()) || (a[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;b[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span>)) &amp;&amp; k == <span class="number">0</span>) k = <span class="number">1</span>, n = e;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果是E</span></span><br><span class="line"></span><br><span class="line">            &#123;      </span><br><span class="line">                m = max(m, h); f[g[e]] = <span class="number">0</span>;    <span class="comment">//将最大复杂度更改 ，变量标记没用过   </span></span><br><span class="line">                <span class="keyword">if</span> (l[e] == <span class="number">1</span>) h--, l[e] = <span class="number">0</span>;    </span><br><span class="line">                e--;    </span><br><span class="line">                <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; e &lt; n) </span><br><span class="line">                    k = <span class="number">0</span>, n = <span class="number">0</span>; <span class="comment">//如果当前循环加了复杂度，当前复杂度-1，标记清空 </span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>), c = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>);    </span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span> &amp;&amp; m == d) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);   </span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span> &amp;&amp; m != d) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3952&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="模拟" scheme="https://hntr.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S-2019-D1-T2题解</title>
    <link href="https://hntr.xyz/CSP-S-2019-D1-T2.html"/>
    <id>https://hntr.xyz/CSP-S-2019-D1-T2.html</id>
    <published>2020-05-02T14:52:20.000Z</published>
    <updated>2020-05-10T08:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5658">题面链接-luogu</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>1.括号序列一定是从<strong>父节点</strong>传递下来的<br>如果用<code>sum[i]</code>表示当前节点的累计，用<code>tail[i]</code>表示以当前节点为结尾的合法字串匹配数量<br>可以得到<br>$sum[x] = sum[fa[x]] + tail[x]$<br>注：<code>fa[x]</code>是<code>x</code>的父节点</p><a id="more"></a><ol start="2"><li>使用栈储存遍历时的信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long <span class="comment">//不开ll见</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">ll n, tot, ans;</span><br><span class="line"><span class="keyword">int</span> head[maxn], pre[maxn], tree[maxn]; <span class="comment">//链式前向星</span></span><br><span class="line"><span class="keyword">int</span> w[maxn], f[maxn]; <span class="comment">//w是储存节点括号信息 f是父节点信息</span></span><br><span class="line">ll tail[maxn], sum[maxn]; <span class="comment">//tail，sum见上方 </span></span><br><span class="line"><span class="keyword">bool</span> v[maxn]; <span class="comment">//是否已经遍历</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[++tot] = y;</span><br><span class="line">    pre[tot] = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q.size() &amp;&amp; w[q.top()] + w[x] == <span class="number">0</span> &amp;&amp; w[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//判断是否是合法的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是合法的就将当前tail值更新</span></span><br><span class="line">        tmp = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        v[tmp] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        tail[x] = tail[f[tmp]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q.push(x), v[x] = <span class="number">1</span>;<span class="comment">//否则继续</span></span><br><span class="line"></span><br><span class="line">    sum[x] = sum[f[x]] + tail[x];<span class="comment">//更新sum</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i=pre[i])<span class="comment">//继续遍历</span></span><br><span class="line">        dfs(tree[i]);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//复原栈</span></span><br><span class="line">    <span class="keyword">if</span> (v[x])</span><br><span class="line">        q.pop(), v[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">        q.push(tmp), v[tmp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            w[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i]);</span><br><span class="line">        add(f[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上方全是输入</span></span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans ^= i * sum[i];<span class="comment">//计算答案</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5658&quot;&gt;题面链接-luogu&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h3&gt;&lt;p&gt;1.括号序列一定是从&lt;strong&gt;父节点&lt;/strong&gt;传递下来的&lt;br&gt;如果用&lt;code&gt;sum[i]&lt;/code&gt;表示当前节点的累计，用&lt;code&gt;tail[i]&lt;/code&gt;表示以当前节点为结尾的合法字串匹配数量&lt;br&gt;可以得到&lt;br&gt;$sum[x] = sum[fa[x]] + tail[x]$&lt;br&gt;注：&lt;code&gt;fa[x]&lt;/code&gt;是&lt;code&gt;x&lt;/code&gt;的父节点&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="CSP" scheme="https://hntr.xyz/tags/CSP/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
    <category term="树" scheme="https://hntr.xyz/tags/%E6%A0%91/"/>
    
    <category term="栈" scheme="https://hntr.xyz/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S-2019-D1-T1题解</title>
    <link href="https://hntr.xyz/CSP-S-2019-D1-T1.html"/>
    <id>https://hntr.xyz/CSP-S-2019-D1-T1.html</id>
    <published>2020-05-02T14:52:09.000Z</published>
    <updated>2020-05-10T08:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间恰好有一位不同，特别地，第一个串与最后一个串也算作相邻。</p><p>………………</p><p>现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的$k$ 号二进制串。</p><a id="more"></a><p>直接找规律</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><a href="https://www.luogu.com.cn/record/28289339">提交记录</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull n,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    k^=k &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (k &gt;&gt; n &amp; <span class="number">1</span>); <span class="comment">//硬核找规律</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间恰好有一位不同，特别地，第一个串与最后一个串也算作相邻。&lt;/p&gt;
&lt;p&gt;………………&lt;/p&gt;
&lt;p&gt;现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的$k$ 号二进制串。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="CSP" scheme="https://hntr.xyz/tags/CSP/"/>
    
    <category term="模拟" scheme="https://hntr.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数学" scheme="https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="NOIP" scheme="https://hntr.xyz/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>查看qq好友的ip</title>
    <link href="https://hntr.xyz/ip.html"/>
    <id>https://hntr.xyz/ip.html</id>
    <published>2020-02-19T06:00:48.000Z</published>
    <updated>2020-02-19T10:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码（输完按回车o)</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5d0d2894d13ddf5aac014a80808c4c5f62739c152ec754629ece62dc7af11578">ea923f9812e2920d06ebb336eb7f63e44ac33d0b9929465112065f33b996783d6d7467ad23a626306c9c83c25bf4a20cb9b082d08c811a2c385579f6d16076a16494e8cc1daa2ab162233f4076382e5356b3bb107dcb6abc3d6396548fa7f7d22c89b255030e42d73919875aa090035e5e83032c223a04fb21a07007fa34a9cf43a98ffd3c1c248b1df98a68f1526babbb939f6b5b556757e4e3b3cf0ab955eaf9d72e292160708ade1dc8ed125ed68d4f40bb5a72b6301f6f6f399724770bc233552ec405581c5518c38c002c5f514c16813ef1151bc9fde997cb26daa0aebc2531f83168428b66ee29f3eca334fe28d05c1636995e8fed16853d5bdef9e4136f9873160270ad5bf8d35a3a17edf6327586cf0fadf7469fc44774b347fd2429468987e7895beddb55744c4d98cf0f5ab8926333ab09ccdd35d37097b48c271eaf47c01ebd13e1a8a8114c4e2cbb8258df29980874a0ad22fccd5497fc43c4f5a7302f3caf73dee08574b197d1a281140dd2fb1dcfe6f8a92a099c908e04ead8d18cb0eaf46981b5b4555b09087f8df53504a9352acdec7a9450ca7e4c56d90ae44e2aca746e01502efb9b13c6a2bc1fd77612e69bcfcd9a6a8b5126c354ee08089fb6e23aeaffd70371602f5a24cf9cd1e395937079848b633a96c729908e6987ba996e8d128ba4aa3a19a5b70cfebd835bd79f98570674557325d4539ae6ff1b3f67ea5a75b9ab4774b1d749cd09b6c7d50bd315ef677a5cd908779ecba98e3fcebe081545b229d2bdd11a76afe11e0d5dc74aeb8422d1e0d352da329605546c3a7eda9fb49aa392e54ab6e37de155e2459bafd6970b8c507896e35721a8bb14d54a264733e7654fddb8cb8cd3d384d8c18a43d6cd093ac621bb3e77dc7e4ae13fcfc8ce6fa477ad7ba5c01178431285f5519700bac11e8adeadb18ba06f1ff37219645b62ee7ba764ab643d0230ecf666b376be1d472c03b4da92627302236a865c298572fa04b0f805e6eeea93f275008df8cce35c1fe5d46c69b8735e0e6d4acb22c552c39a0b05a122a20635389178ff8251baa16a71d3e1d257315b51322188492cfbe3875f23343ca512d767be6bb1558771cfb0a41506af61db566b103feb97e89b16cea96bd5bbeef7cb77de6eff333427fb1aec48cbfd161076edd3f860b8106ad8073852de825acf77372fcb9d8a18ca5696805c2de11f99a53b00207b07c63d40df87798b239f07470189ffb803785422d87315386040e490e14f5c33745f0d13974d38ed573fb57d9ad9793434d446d9f0b40901cb4218472c3b49fad221a16befb5678670e03c5074cded8819fe261393cc4d2fd059fd83b3cdc1b6292ddf8418717ee968b24afffd3c21bd9028bd36f3b6d4267e189ae14e378a2f30012ab588c0f24536ddec1b2df3124a08e046602eb068363281fa165549fdb1b715f00daff21d88009cba67894055a98bbd9540bf802274e201bc9e2ac16b213cf0850046c3918a5992fcb0b4d193f1287b367d71b7ecb3eab8e49d3dfe8465d09ff4c37543a561a2497d1f147f65b6e1da8cfffe8cd6d2461ea438efe8a1ad36f70619ca6989eed77e5cb46ccd28cd8c902f4db85eac5af10ea7adcf52f6816e2c7f6e2ecfcf224c560c953ae71e1c8c46638af5e0eafee0fd45c38289e9bd1734aa01f547471b702b6a60980824ae5a873f42f54942584d20eebdfdee4300b7271f5046b96d0e9fff7eda2cb09f839e1976e89a7ba0de89c1ef48f55d68dc15c0c47690f21959e48edbd400c8df7d87ff2049aec3ac15d8cfcbe65bad5f392670916424a4cd34c411b3559c6e26f887ef4836b84d6dc3daca6763bbf83f747e6edb6a2d93dcc0583aee53cfa40bb324cf3d07b8973ddfbfb5836ce3ae4e2ff7c0eb56271fef666365bbb9e2f26dcb4fc76da332343103b5d453e653e71b5c17ad592dc77c9fe8cb28bf4047da0cb21af331969476a4bf322491a350aa61b283c7b7ba1d3dda656edde3b389ea0582b3e94ac3c638c688a92850ffd22cc625c8a85aeaa523b9f067ca1bc4977d37a9066f4a76e838c9f83acf460ceaae1bbd4eec932e1c61542099ee42d40df1f4fc2c609fe89d3c352b01dbba567844640b960f3e860f14074e6d08b2639ba48571294f10bdd10245a5dd2e97dbd6cce6273fa1ae8b6b308c66623ec524bf4becf96758a3a18ddfec8ab3e453e708e4d9b211b453bd064c3d2dca5cb64bb31ce2b71f9edfc94c88221116705baf134dc28177940591a27815c978efba5fac6c69d853bf3ef0e46a8d7bfafe9e5378652cca858e1dd6115134d869e8b1add05844bd5d25222f841333c16d8779560f236c370ffe6e63d14e6ce9befbc3d147c1ac79568dcc59c1c62faa021f9ab39137c23413c65aaadac05e5505cc8425ed14adb8be730907fcba17fb3a71f2a511a574f09763b62441a7ab049b4597de13bf436f3b094237b420002610146d68c09e04c489f49400cec166e67d77cf8c87623a5e66382703b87ebb2061f371c83f693e57c98a9ceefaddc223f14f63ab756e1a4ee91947bfbfc86d7e4399c5c48e3c0929181a40600f8d1b1ee456ad55eeeac0babbe244cd767e406260bba226d725156e06c7a7fca262d976273a2e1244b6441844ea2f57d7fb45a4caba88827cfc8952fd5fff93690d764212f4f19e155fb36767cd6004912e40ebfee82d7af0b6a51b8eda1ee614189f906c0d53728f670997bf519133c99e987dadd0feef3d1bb0e61696e54b27bdba396705e3e33f91696ca294e03636d9dd909a2675aff9d5aef0fa3b2a2b5ba79aab3cab483e301ecee2f69b917780734ebd0bf6fac739c71ace50eef5c40d37c6961626cac1266f92ccad58f896973c240ac509c4a056b52a9f6aa79801765f531ce21c490332986cc53615faffc4a66cf8b6213b5b7989da2ae20a8b65fd3e1ce7918f7dad7bda5e275275ce5b34c851033990548d180733ff0b26ab83865af7408279573a79233f39079f981ff261d2a818c7607cdb292eb82e1ad5bb87f6a1778113bc2536d92bbd76fb2e5288b1862432ed2ca24b7b14ab8b9ce43864400002ebb1ab898add2fb2580b69bf6c602df20bca0f92aa2b35d9bace3a7badd54ad1202a46ac9a7fd048b5752dc84d8ab124aa4f7b8931ab9fa616895795fed8d91cf38ee5f5787433abd38d952f6757a4bdeaaefe159ae00099af2e382a50a933bf7073350081a9c48f106a5a42b7b159978b375b13c30961e56edcad22817e8d9ff9125cc38aaa10c0d17fbe9973cdb4350d5a6721262e7086cfdef0f434620afcb3841ac5265f6eb39a6b5d822e954420f4f215db953be6866a763f13ecd03a9bd77f0d0247f608c868bc46136f970ae667cd526ae505fdb156a7580ff9a7b370c10b5a8a0997f59a658f439c8253d005412116b8c6d485ba7796c3b4d52953d9a2494ca5acfaf0a822c4afff549f2c261b64305bc0207b0049daa799c033f0d6d8e5ad142e4c0de3ccc039c77b8914a839232cac2595545901a64fc579e152650e5509ec3a0bf5d0826621bb148bfb6e46c4e1bbb1a0ead422f28bbaa1f576bf29da5f25ee667b3a98ce6f09e5357afaedc0f46bffc45331b36d97236bc3d51bba0711fc19a76126a045aeeb46bfc462997b4750aa1eead72396812ba2dfdb8bf32e528467bc402eb02f46e6cf36a6a9428c3d9d9f39a8c114d1c3d1593ca467cfcda3c549d16118e1dcf48c8b87495ff27d0b780ff73a7c2466db5df0cc82a7ab453a007ea96fa2e7f8758f2ac366e1e25e85efab283b2dec9e68e096c9fcb4fa75d49985854003df1902575b26566bb9ae692b9df7b29f7ec0012f19461797abff0426bbb036a156f63cd09dd734b6d448b3c89c1972fe17e6c90675cd66e50882aa0642c75fc12931601452723bcf547e034ab7f3d6bda78b55d9d6967417371b4513643f20ef76847314f63f9fa4161b657aeb7913def7c16b00b292b50cdb6e935b2b7d7564075e7da33d210cbe0d1f38d2c5c18b4bf95d2c5f976829fefa212fcfb6aff9e177a52cecd595ec2ca2e033cc0581a1b3f0428febb8c7bfd1c205773c8fee49b4479287949da5c2977f09040f33b58fb58d2f54504f2bd39fec1ebf79b4d462eabeb9fed487e82b1f5a562d140346cc548e9d5e14270fffb3a2ab2bcf2a518bc7c8f402ccd0338a22d4bda4f34b3095810185895ec905dc78776293dee02b5609364c60548658ba9c6496798f1b1cd76ec138320483228caa13d6261549cac90acee296c957d3ca44a9f2baf142e5b7057f08549856789fbfb51c98d9e98738ededa780ff7ecb56fdcf17410baa302af13e832908778a9540e1f9bb8b0d20e5858622a0e6eef7a1c1d475bae728018fa8dc5b2f8fc86ef56117625ae2ea7bf915b5132027ffd96a82d0ed296fce807c521e00e0be1388ccaf7b8d86bbe4f11acfb4d53ac9502a6a0ac4ff25d25b8d260341744abe689a96b38e4c0d402811dcdeac65e8a79623fdf6461b2641bc2076e515c8bd86b6cd9b69518192da20ba32623528a82b4d61bc9782e23f3a1f0d2b5a41f39bfc59a7f8c20fda0008ec24833a9fd573c5ff9bbf2e48c5b6204811cc612dbc00f5edc51fea8b4697dfe9b8e798e3cafa4d0506eb20ab1f73eaee19c02e808c94de25dd3e38648a69f387152e9b3209e30dcd67b36fc7bef76461a162380508bf99aa01a7452634c9bec214b4481702cab87a5803db2ab867479147ad52b0f1c5880b43b668afb8225219327ac458205ff293e3dfbfc1d21f138097d008e41317525964da1912d1527e322a45fddf26eea9c7a79ecf9141674c41d9495977d906319a4db2d95859cb7bc4ca8a58e233fd35b1b874a414c20f376e7e2bc4865ecfac5fc953ea728613d096c1a71ebddda95f35cd4a62b56d5ff7c531d9f864aa9f6c0a142ae3f46cd36fcb541124f2d917b7243d549fc4d7a2b95314ed846c50ba20ef3ae62bb2bfa30e7f7d26fa7d60735583f0f4564d6b523b23bd3fd4dcf758cd1674f6bcae71b4b159bb86aa0cd2c80cf4224b746433a55bc3507b46959180b0a9fc08768277a33ae173d082145371640cbf946d3fcbdce3b981e0aa05bafe556e67b593abd708105925463c3bb973153c02b68925cb487b0d2f0b942f7d794e90a88f68b8e385caf92ab1d552a205ac5e48468a772a8c9c68a8b3b9efcf40d0aac6d479e128ea09b315c907af9db0d8dbaef304576ea95ad07cbe609328abe5acb8cb7c8b9506dd904c69f5c26258d5c8a81509084159ab44070697c14e9ed74c1ece848a8346900f63bc5ebbbcba190bc5c444db04ba62847b96aeb76b90f8083c308741707ae533a6d1b79650b21641f271ae965ff185081a09ed1ebf60297d3541be7460f61e7b28a7676fbb6270a806fb37e4f62c26209450cd81a299b16f851be095eb2a3d83</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密的文章。</summary>
    
    
    
    <category term="技巧" scheme="https://hntr.xyz/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>woaw</title>
    <link href="https://hntr.xyz/tr.html"/>
    <id>https://hntr.xyz/tr.html</id>
    <published>2020-02-17T13:59:54.000Z</published>
    <updated>2020-02-17T14:11:42.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码（输完按回车o）</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="793169959577f3fd48583533a97a4e33effefe0d74b84e4a7e53e1007ceced4d">c0c9fba2e668efce9dafdf903adbc6233db00d272b690b1624dcb60d728a19526440bf06214c23fd48cb61c2605c5d1d174a0e7bd21a79e4f7e6a1571a99986af9cb7da7d663d02717b665c2ca6bbbcf2b44a17cf9bb8a20e404f20ee9c98cf5c62f7cda932a89bd31d830e389d596c4f9e9ceadebb5a96104804651330137ec1d66b1acde31de0ce652ea9992dccd1c31d6997b93d818f7b2df71308c7e5608e6d0ebdd77e4156965e5becbb9afd72b97932dd15f15dd401981f86b49731e53521d7f4299ef6710ac6b8bc908b30f44a419637cb06063e945e0a61c07cda94297740811ad59e774cfe73d678b316b66c45ff259f6c8db437116e6afd5b5030ce95dbb4e576ca37b71394bf84eaa6fea73fc8652d83c775b2a0ff837bef1f39edf53e57a8dcf9e8b351cd1548cdb12eca560ed9782bd954cbd5aa883667e54e8f73ed3055ad747633812e118ec6cff3c6d993293064a14ed42695da132fd1978cbd7a4e759a21158ca6b3bf469687fe090035d6f80697c92c3b31ff19db260deb6adff22404824ba4563eda84ff16e26c00c696f8946a83b9b1d6b3c5e84b8cf98239ea09a3fa0d71d55c59f8b561155269f95bed2a4e0790e04bf856225af5ed87e22bbfa792a754f0709ff33bf7c90a5a13c5c1ae6858cd2147169bcaf7328035cff619367ef68f4fa43f8a574a590a882dff43ec372b3a083c4b2bbf032560f61f9d2c8c69438234af94a50732174679b26c227b12584d090c52b075122a3d918e811d583249dd386a0a146977d5961e3c57dd5ae86f445c96575beeaf8d4e70a37256e368ff2835120f3dec5a3c373f875d2af9882af3c6fdd1a7746c2b0cb52b78bdcf8c891e02b4c97a1862a3005bb957de34bf12129fb0a30c579b198fee33c0c136f42f950b54a4548e092d13c0a8ea5e37c7ab77e3e4d3684cf980321b5bc802ed49ba713e8170e5e244fa17d0370360d068b1371ee07c1e5308bd4d16a4a882fc14b07668a9fd6ffee4419ff5b88f836fd401a4042c7ef79ff0c1048c879bf77f0dd82c2c38017c7e1d6f6423c16c65d56a0f77a72861df4f0a089902c7f072a1fe37cf4fc97bed08567857635e108e68eafc37b174a1235c1de6d2120425c5c58b831b1f2b94ddfca47863232bcb5dea2ae84a62ffc4f1a13ba1eef13d674df958da474de7965d123433f4403e55af43304a730eeda58a569c937d8c9f8e3a4110e047613ead02cbc383cf0c8161bb65ee2248fd1063054b5e3c621201c2d57f33be47c281d95e29595f0aa5911f88a92a57fce1a2b96728bfc71ee6ba1e8ac69edc021c19185bcad2e981100abcc528ce40d7fc6e32ef2fe009499e620253d2f897f896a69b8a7334ea6fbdc143508bf03e9887e55c5cdb71813f903ed4087f7948f73239c6441f946148607370cdf6b73d095cb0ef335970a81dd8a58cd59cd67c70d9e0aaf1692fe5ae0e054fc46dac561224cf16eac6742231c37023bc6fe61c8f7388de49c8d52a58766b1ec46b7f32eff0183b87049a5e0042581c82ef12b207b6a944b1bf39a0782ad176eb5e2b74dd12af80a21a61b16968cee89ead4044195fd0f4e9ce0ea7141675bddf6d0b88ce9ab310486652fa1c30647b39f8134b5f332fbf6d4062f875ff933322d07dc5fec8fda20bf46956f39d3f7b0e8558bdf5e57670fbf94d8f9cf9b58e15438ef3c8cb14a13fbd7ed7f446304ee1b3ef0719b707fcf9a995704b25a368a838d746a9d8b26c7a82cdedb12af69403aae5b6306b5e62d94fe7d74b99601d877cdacd26df943ede435fe310888fce2ab67b598e561a1a67b7345658839d72b73c1b142dca919ab7aa06acdda76a0e99436e1339d0c042ebd8bb632f2b38ab8d26887b094096332618474e5b0b4a798ec6f1e54fa485ba1a4a12f17a61fecc3b062e7f1e2f38f61da8a55291b950763d27693c17cd2d7e6bfae16e7ca10b92c11b4c78837ca969b3f400704e813f40013bc51d434f047d7c9c791b8da9c939a8274e3dafb668e1b63b9828a5d9c80ca7dd018c84e6c9b44b9637a3fafe0f49b26487f1cc078e210ab6787fbe700637f9a8a7f72fba6ccf122eebebae3711dd6e2c9442d1ecee6a41d254b269c14ff7abe59f13fe298fd62ce94701f5b3062db610ba148b3cc977048629462cddc55a3448b6f66a6a9d277293b36f4dbb2bf40ed34a30523bf29d4bb6ef00d67f5dbaf3b0a94fe8872812cf17f936b702a47cca9c765269e5436fa533cb5f69bd30de7f35c72b7e0f432447baca29564c169d9fbd5e425b2a032b9313263df7ce1a26dfb81e524028e721bb50667deac069fd7c9dadea290bf21e3922bacaf9336415e024e4a5140d83e740516fe6264d2704495a432f6023f4c68280057901da5f1071dd52b75dd7a75b5ed7397c4c7a285fc64f72f483299e41a6d5fdfe7cb0c923d85958e2c1648c9e69e0b01b2fdf3a2037f335606e17546674e6e90d88b46a3e887a0625bf37f5042d1e5962723ef938e64d940ac4754f41c32a876420fb56bfe6b3934d8afe16f242fdf70da3124c2012bd4dbfbbbedbae56b223f97fea8e6c994a3975217079a22711c663b9b25acea9782bc776e4f7386c17778f38261858aa65b7e4fc929f5ccfb1b722e0acd0e7d9b9f527d1b9b94b8f3c6666371e4f22ec83b382f81122197ae008978046c6ea2a5d163dabc13807fd95c5f2219ef38170c1f73976005acf0a1f449da06d9ba22f1cd4fc418eb3a8a087880dbb1f3deff87e92188483668a57f353157f76a9ce0e23d7ca922c2bcd9410d18829da669a5cf2dd21f30f56011a846bd2504c8ea1a2fc3eb93fb05a80515cd973fe350890044fccdc2aa62b325b17f8fd0a93f5c226f42be7e81e185baf29710672442b5517088205a9780220be817ad0159508802d7888457935fb06cedadfc6d6b3ddbc529ca7ee4cfa57ae8031d40a6f56a87ee5b54740d123fd8b84ced9c24eec2b2d4e682f703f8ff5839c6c7ec0198fdc7ead46f0c0c794dba8dac0781e42980a52931c65c8f50a5542e878abb32ba50b78383d67b92621cb335cdf7656fb1007619e1f6f8e85d063c861bfd7c6efd2507d0fdb088372de86db858e59588350c2f9420659f404ccbcdb7c3d55d0097679e1e60205ccfc1214ffe10364ec1daa6d61cfcbb5ae30d55fa44011f05c0860ff24d5d7c4b1a4d9dabb6e390163fcf386d27b3dc3d61a62848a956104b89e728af725258d6a7a65394a4de91a1865c16ff7ee248c8a30e8fb828d0b7603ff5d7680d599bae44ee397e53b926112126941734d549d7547cb87dba5d3cd43d224bf3418d1ac671ae904f2a66728c778b95487e142babe5e36b3d25d793f5e357fc3076e25c04be7fca98b304486abbf79e7293a159d6f1157db0dc7f2d1bd6ca2b7f3bd0944fa7260e98cd5efff229</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密的文章。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>P2286[HNOI2004]题解</title>
    <link href="https://hntr.xyz/P2286[HNOI2004]%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/P2286[HNOI2004]%E9%A2%98%E8%A7%A3.html</id>
    <published>2020-02-03T14:41:00.000Z</published>
    <updated>2020-02-11T09:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题目可以算是一道<code>set</code>的板子题（在CJC大佬的提醒下恍然大悟，<a href="https://www.luogu.com.cn/blog/L-O-A-T-R-Iridescent/">CJC的博客</a>），于是这篇题解某种意义上其实是对于<code>set</code>的讲解和复习。关于<code>STL</code>的话，全称为<code>Standard Template Library</code>，说白了就是一个非常多功能的库，引用时按情况引用，可能会有<code>set</code> <code>map</code> <code>algorithm</code>等等，按情况来分析，用途很多，有封装好的快排、大根小根堆（优先队列）、二分查找、全排列、各种神仙玩意儿。<code>set</code>则是其中的一个工具。</p><a id="more"></a><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>set</code>和<code>multiset</code>的区别是，后者可以有重复的元素，前者不可以。<br><code>set</code>插入重复元素可能会不成功，所以有重复元素要用<code>multiset</code>。<br>用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; //set所在的库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//定义方法，其他类型类似</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        st.insert(a[i]);<span class="comment">//插入方式</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; st.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//st.size()返回这个set的大小，整形</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i; <span class="comment">//迭代器，类似于一个指向set中某个元素的指针，不可以比较大小，不可以相加相减，但可以++i（迭代）</span></span><br><span class="line">    <span class="keyword">for</span> (i = st.begin(); i != st.snd(); ++i) <span class="comment">//由于迭代器的特殊性，只能用这种方式进行循环</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i &lt;&lt; <span class="string">&quot;,&quot;</span>; </span><br><span class="line">    <span class="built_in">cout</span> <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = st.insert(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result.second)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first &lt;&lt; <span class="string">&quot; already exists.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first &lt;&lt; <span class="string">&quot; inserted.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的关于<code>set</code>的用法和函数详解，可以访问<a href="http://www.cplusplus.com/reference/">C++ reference</a></p><h3 id="这道题目"><a href="#这道题目" class="headerlink" title="这道题目"></a>这道题目</h3><p>题目简述：<br>凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。</p><p>每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值$a$（$a$是一个正整数，$a&lt;2^{31}$），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。</p><p>被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为$a$，那么它将会领养一只目前未被领养的宠物中特点值最接近$a$的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为$a-b$和$a+b$，那么领养者将会领养特点值为$a-b$的那只宠物。</p><p>收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为$a$，存在两个领养者他们希望领养宠物的特点值分别为$a-b$和$a+b$，那么特点值为$a-b$的那个领养者将成功领养该宠物。</p><p>一个领养者领养了一个特点值为$a$的宠物，而它本身希望领养的宠物的特点值为$b$，那么这个领养者的不满意程度为$abs(a-b)$。</p><p>你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。</p><p>问题解决：</p><p>知道了<code>set</code>怎么用，辣么就好办了（好像还要知道一个<code>lower_bound()</code>）</p><p>我们只要把每次宠物的编号插入，然后直接查询，查询的话也是用<code>STL</code>中的<code>lower_bound</code>和<code>uper_bound</code>，然后这道题目就可以A了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; //万能头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//定义set</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator left, right;<span class="comment">//定义迭代器</span></span><br><span class="line">    left = --s.lower_bound(x);</span><br><span class="line">    right = s.lower_bound(x);</span><br><span class="line">    <span class="keyword">if</span> (x - *left &lt;= *right - x &amp;&amp; *left != -MAX_INT)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += x - *left;</span><br><span class="line">        s.erase(left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += *right - x;</span><br><span class="line">        s.erase(right);</span><br><span class="line">    &#125;</span><br><span class="line">    ans %= <span class="number">1000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> hod;</span><br><span class="line">    s.insert(-MAX_INT), s.insert(MAX_INT); <span class="comment">//通过插入最大整型和最小整型来防止查找溢出，这是一位大佬的方法，非常秒！！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (s.size() == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hod = a;</span><br><span class="line">            s.insert(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span> (a == hod) </span><br><span class="line">                s.insert(b); <span class="keyword">else</span> find(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完事儿~<br>考虑在写一个关于STL的整合，这一切都要从一只🦇说起……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这道题目可以算是一道&lt;code&gt;set&lt;/code&gt;的板子题（在CJC大佬的提醒下恍然大悟，&lt;a href=&quot;https://www.luogu.com.cn/blog/L-O-A-T-R-Iridescent/&quot;&gt;CJC的博客&lt;/a&gt;），于是这篇题解某种意义上其实是对于&lt;code&gt;set&lt;/code&gt;的讲解和复习。关于&lt;code&gt;STL&lt;/code&gt;的话，全称为&lt;code&gt;Standard Template Library&lt;/code&gt;，说白了就是一个非常多功能的库，引用时按情况引用，可能会有&lt;code&gt;set&lt;/code&gt; &lt;code&gt;map&lt;/code&gt; &lt;code&gt;algorithm&lt;/code&gt;等等，按情况来分析，用途很多，有封装好的快排、大根小根堆（优先队列）、二分查找、全排列、各种神仙玩意儿。&lt;code&gt;set&lt;/code&gt;则是其中的一个工具。&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="STL" scheme="https://hntr.xyz/tags/STL/"/>
    
    <category term="set" scheme="https://hntr.xyz/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>LCA最近公共祖先</title>
    <link href="https://hntr.xyz/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"/>
    <id>https://hntr.xyz/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-02-16T12:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习了 <code>LCA（最近公共祖先）</code> 这个高级的东西。。<br>于是乎来发一些理解和题解以便以后复习。</p><h3 id="什么是LCA"><a href="#什么是LCA" class="headerlink" title="什么是LCA"></a>什么是LCA</h3><p><del>LCA就是LCA</del><br>就是求一棵树上两个节点最近的公共祖先，那么有什么用呢，用来做题。</p><h3 id="LCA的实现"><a href="#LCA的实现" class="headerlink" title="LCA的实现"></a>LCA的实现</h3><p>这里用到了“爬树”的方法找<br>例如两个节点$x,y$:<br>规定$deepth_x&gt;deepth_y$<br>1.让深的那个节点,$x$往树上爬，直到$deepth_x = deepth_y$；<br>2.让两个节点一起向上跳，如果碰在一起了，那么就找到了。<br>嗯，真是生动形象<del>好理解</del>呢！</p><a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>一种神奇的存树、图的方式：<br><code>edge[cnt]</code>数组存储了第<code>cnt</code>条边，其中<code>to</code>表示这条边指向的节点;<code>pr</code>e则是指同一个点出发，比当前点早一个添加的<code>边的编号</code>，别的大佬好像是用<code>nxt</code>。<br><code>head[x]</code>存储了从<code>x</code>出发的所有边中最近添加的边<br>感受一下，会懂的😉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, pre;</span><br><span class="line">&#125;edge[(MAXN) * <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="增加边"><a href="#增加边" class="headerlink" title="增加边"></a>增加边</h4><p>有了之上的存储方式，那么就有了下面的加边方法（<code>cnt</code>初始为0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//edge[++cnt].to = y;</span></span><br><span class="line">    <span class="comment">//edge[cnt].pre = head[x];</span></span><br><span class="line">    edge[++cnt] = (Node)&#123;head[x], y&#125;;<span class="comment">//这句和上面两句一样，但它压行了</span></span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>深搜初始化<code>deepth</code>数组（每个节点在树中的深度）；<br>利用倍增思想，类似<code>st</code>表的方式，预处理<code>father</code>数组：<br>$father[x][i]$表示$x$节点向上爬$2^i$后的位置<br>更新方程式：<br>$father[now][i] = father[father[now][i - 1]][i - 1];$<br>解释：现在向上爬$2^i$的位置等于向上爬$2^{i-1}$再向上爬$2^{i-1}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    father[now][<span class="number">0</span>] = fa;</span><br><span class="line">    deepth[now] = deepth[fa] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= deepth[now]; ++i)</span><br><span class="line">        father[now][i] = father[father[now][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edge[i].pre)</span><br><span class="line">        <span class="keyword">if</span> (edge[i].to != fa)<span class="comment">//遍历下一条边，只要不是指向他父亲的就继续</span></span><br><span class="line">            build(edge[i].to, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>lca的关键部分,<br>看代码挺好理解的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y])<span class="comment">//方便起见，规定x总比y深，不然换一下</span></span><br><span class="line">        swap(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//让x向上爬，但不能比y浅，这里可以直接像我这样暴力30次，没有关系</span></span><br><span class="line">        <span class="keyword">if</span> (depth[father[x][i]] &gt;= depth[y])</span><br><span class="line">            x = father[x][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;<span class="comment">//特判</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//xy一起向上跳</span></span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = father[x][i];</span><br><span class="line">            y = father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];<span class="comment">//最后返回x节点上一层的节点，即为最近公共祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总的代码"><a href="#总的代码" class="headerlink" title="总的代码"></a>总的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500000 + 9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n, m, s;</span><br><span class="line"><span class="keyword">int</span> father[MAXN][<span class="number">30</span>], head[MAXN], depth[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, pre;</span><br><span class="line">&#125;edge[(MAXN) * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to = y;</span><br><span class="line">    edge[cnt].pre = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    father[now][<span class="number">0</span>] = fa;</span><br><span class="line">    depth[now] = depth[fa] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= depth[now]; ++i)</span><br><span class="line">        father[now][i] = father[father[now][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edge[i].pre)</span><br><span class="line">        <span class="keyword">if</span> (edge[i].to != fa)</span><br><span class="line">            dfs(edge[i].to, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (depth[father[x][i]] &gt;= depth[y])</span><br><span class="line">            x = father[x][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = father[x][i];</span><br><span class="line">            y = father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        addedge(a, b);</span><br><span class="line">        addedge(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lca(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完事儿<br>peace~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习了 &lt;code&gt;LCA（最近公共祖先）&lt;/code&gt; 这个高级的东西。。&lt;br&gt;于是乎来发一些理解和题解以便以后复习。&lt;/p&gt;
&lt;h3 id=&quot;什么是LCA&quot;&gt;&lt;a href=&quot;#什么是LCA&quot; class=&quot;headerlink&quot; title=&quot;什么是LCA&quot;&gt;&lt;/a&gt;什么是LCA&lt;/h3&gt;&lt;p&gt;&lt;del&gt;LCA就是LCA&lt;/del&gt;&lt;br&gt;就是求一棵树上两个节点最近的公共祖先，那么有什么用呢，用来做题。&lt;/p&gt;
&lt;h3 id=&quot;LCA的实现&quot;&gt;&lt;a href=&quot;#LCA的实现&quot; class=&quot;headerlink&quot; title=&quot;LCA的实现&quot;&gt;&lt;/a&gt;LCA的实现&lt;/h3&gt;&lt;p&gt;这里用到了“爬树”的方法找&lt;br&gt;例如两个节点$x,y$:&lt;br&gt;规定$deepth_x&amp;gt;deepth_y$&lt;br&gt;1.让深的那个节点,$x$往树上爬，直到$deepth_x = deepth_y$；&lt;br&gt;2.让两个节点一起向上跳，如果碰在一起了，那么就找到了。&lt;br&gt;嗯，真是生动形象&lt;del&gt;好理解&lt;/del&gt;呢！&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="LCA" scheme="https://hntr.xyz/tags/LCA/"/>
    
    <category term="倍增" scheme="https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>ST表</title>
    <link href="https://hntr.xyz/ST%E8%A1%A8.html"/>
    <id>https://hntr.xyz/ST%E8%A1%A8.html</id>
    <published>2020-01-20T16:00:00.000Z</published>
    <updated>2020-02-02T15:26:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习了 <code>ST表</code> 这个高级的东西。。<br>于是乎来发一些理解和题解以便以后复习。</p><h3 id="什么是ST表"><a href="#什么是ST表" class="headerlink" title="什么是ST表"></a>什么是ST表</h3><p>ST表的功能很简单：<br>它是解决<code>RMQ</code>问题(区间最值问题)的一种强有力的工具。<br>它可以做到$O(nlogn)$预处理，$O(1)$查询最值（ohhhhhhhh）</p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>怎么做到的呢，它运用了<code>倍增</code>的思想。</p><p>拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的)</p><p>那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值（注意这里的编号是从$1$开始的）</p><p><img src="https://hntr.xyz/img/st/transfer.jpg" alt="transfer"></p><p>查询的时候也比较简单<br>我们计算出$log_2{lenth}$,然后对于左端点和右端点分别进行查询，这样可以保证一定可以覆盖查询的区间</p><p><img src="https://hntr.xyz/img/st/ask.jpg" alt="transfer"></p><p>所以就有了这两个边界，$[l,l+2^k-1]$, $[r-2^k+1,r]$<br>至于为什么会是$[r-2^k+1,r]$，你只要设左端点为$x$, 并且$x$满足$x + 2^k - 1 = r$, 然后就可以推出来了。</p><h3 id="例题和代码"><a href="#例题和代码" class="headerlink" title="例题和代码"></a>例题和代码</h3><p>给定一个长度为 $N$ 的数列，和 $M$ 次询问，求出每一次询问的区间内数字的最大值。</p><p>上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 100000 + 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LogN 17 <span class="comment">//顶多2的17次方就可以从左端到最右端了</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MaxN][LogN], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//快读 很容易暴毙</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();<span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x + (1 &lt;&lt; len) - 1=r 草稿请无视🤣</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = log2(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max(f[l][len], f[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]); <span class="comment">//关键，这样可以保证覆盖需要查询的区间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i][<span class="number">0</span>] = read();<span class="comment">//预处理的时候存在0的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]); <span class="comment">//转移方程式</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = read(); b = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ask(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，没有四倍经验。<br>peace~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习了 &lt;code&gt;ST表&lt;/code&gt; 这个高级的东西。。&lt;br&gt;于是乎来发一些理解和题解以便以后复习。&lt;/p&gt;
&lt;h3 id=&quot;什么是ST表&quot;&gt;&lt;a href=&quot;#什么是ST表&quot; class=&quot;headerlink&quot; title=&quot;什么是ST表&quot;&gt;&lt;/a&gt;什么是ST表&lt;/h3&gt;&lt;p&gt;ST表的功能很简单：&lt;br&gt;它是解决&lt;code&gt;RMQ&lt;/code&gt;问题(区间最值问题)的一种强有力的工具。&lt;br&gt;它可以做到$O(nlogn)$预处理，$O(1)$查询最值（ohhhhhhhh）&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="倍增" scheme="https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"/>
    
    <category term="ST表" scheme="https://hntr.xyz/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://hntr.xyz/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"/>
    <id>https://hntr.xyz/%E7%BA%BF%E6%AE%B5%E6%A0%91.html</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-02-01T13:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两节课学习了 <code>线段树</code> 这个高级的东西。。<br>于是乎来发一些理解和题解以便以后复习。</p><h3 id="什么是线段树"><a href="#什么是线段树" class="headerlink" title="什么是线段树"></a>什么是线段树</h3><p>先来康康这类问题：<br>长度为$n$的数列${a_1, a_2, … , a_n}$<br>（1）求最值：给定$i$,$j&lt;=n$，求${a_i, …, a_j}$区间内的最值。<br>（2）修改元素：给定$k$和$x$，把$a_k$改成$x$。<br>显然你可以用<del>暴力</del>去做，但是</p><a id="more"></a><p>如果在加一些操作，比如<br>（3）给定$n$个元素${a_1, a_2, … , a_n} $：<br>• 加：给定$i, j&lt;=n$，把${a_i, …, a_j}$区间内的每个元素加$v$。<br>• 查询：给定$L, R&lt;=n$，计算${a_L, …, a_R}$的区间和。</p><p>那么暴力就暴毙。。。</p><p>于是就讲了线段树。<br>大概长这个样子：<br><img src="https://hunterqu.github.io/img/xds/xds.jpg" alt="xds"><br>他的每个节点都含有l和r代表了它这个节点所代表的线段或者说是区间， 所以一颗线段树就可以把一根线（一个区间）分成线段（子区间），就比如上面这颗。<br>对于解决区间最值的问题，每个节点多出一个<code>num</code>去存储当前区间的最值即可。<br>然后我们来看操作。</p><h3 id="线段树的基本操作"><a href="#线段树的基本操作" class="headerlink" title="线段树的基本操作"></a>线段树的基本操作</h3><p>首先我们来看个例题，<a href="https://www.luogu.com.cn/problem/P3374">Luogu P3374 </a></p><h4 id="例题1题面"><a href="#例题1题面" class="headerlink" title="例题1题面"></a>例题1题面</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>如题，已知一个数列，你需要进行下面两种操作：</p><p>将某一个数加上 $x$</p><p>求出某区间每一个数的和</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p><p>接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：</p><p><code>1 x k</code> 含义：将第 $x$ 个数加上 $k$</p><p><code>2 x y</code> 含义：输出区间 $[x,y]$内每个数的和</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出包含若干行整数，即为所有操作 $2$ 的结果。</p><p>这是luogu的线段树模板题1，涉及的操作有<code>建树</code>、<code>修改单点</code>、<code>查询区间和</code></p><h4 id="例题2题面"><a href="#例题2题面" class="headerlink" title="例题2题面"></a>例题2题面</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>如题，已知一个数列，你需要进行下面两种操作：</p><p>1.将某区间每一个数加上x</p><p>2.求出某区间每一个数的和</p><p>涉及的操作<strong>还有</strong> <code>区间修改</code></p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h5 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h5><p>首先线段树是存在数组里的，数组每一个都是一个结构体<br>注意因为是数组存树，所以要开4被MAXN</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">//表示区间左右端点</span></span><br><span class="line">    <span class="keyword">int</span> sum; <span class="comment">//在本题中sum表示此区间内所有的和</span></span><br><span class="line">&#125;tree[<span class="number">4</span> * MaxN];</span><br></pre></td></tr></table></figure><p>然后就是建树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// index指的是当前节点在tree数组中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="comment">//如果左右端点一样说明他是一个点，更新sum为输入的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[index].sum = input[l]; <span class="comment">// input是输入的数组</span></span><br><span class="line">            <span class="keyword">return</span> input[l];</span><br><span class="line">        &#125;</span><br><span class="line">    tree[index].sum = build(lson, l, (l + r) &gt;&gt; <span class="number">1</span>) + build(rson, ((l + r) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, r); <span class="comment">//递归继续建树</span></span><br><span class="line">    <span class="keyword">return</span> tree[index].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h5><p>其实后来发现没啥用， 因为可以用区间修改的函数，l=r</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].sum += k;<span class="comment">//只要是遍历到的节点都要加K</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree[index].l == tree[index].r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= tree[index &lt;&lt; <span class="number">1</span>].r) <span class="comment">//遍历左子树</span></span><br><span class="line">        add(index &lt;&lt; <span class="number">1</span>, x, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt;= tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l) <span class="comment">//遍历右子树  index &lt;&lt; 1 等价于 index * 2 但是位运算更快</span></span><br><span class="line">        add((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, x, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="区间查询（无懒标记）"><a href="#区间查询（无懒标记）" class="headerlink" title="区间查询（无懒标记）"></a>区间查询（无懒标记）</h5><p>区间查询就是，每查到一个区间，有三种选择：</p><p>1、如果这个区间被完全包括在目标区间内，那么加上这个区间的和，然后return；</p><p>2、如果这个区间的right&gt;目标区间的left，那么查询这个区间；</p><p>3、如果这个区间的left&lt;目标区间的right，也查询这个区间;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchlr</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right) <span class="comment">//此节点被要查询的区间包含</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[index].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree[index &lt;&lt; <span class="number">1</span>].r &gt;= left) <span class="comment">//要查询的区间有部分在左子树</span></span><br><span class="line">        searchlr(index &lt;&lt; <span class="number">1</span>, left, right);</span><br><span class="line">    <span class="keyword">if</span> (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l &lt;= right) <span class="comment">//要查询的区间有部分在右子树</span></span><br><span class="line">        searchlr((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题1代码综上即可，总的就不放了，<del>因为太乱了</del></p><h5 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h5><p>然后便是例题2，这一题不同于前一题，因为涉及了区间修改，那么就要涉及另一个东西：<code>LazyTag</code></p><p><code>LazyTag</code>我感觉跟图片懒加载有点像，就是不涉及真正使用是不需要深入加载</p><p>首先，懒标记的作用是记录每次、每个节点要更新的值,优点在于传递式记录而不是全记录（全记录还是很慢）</p><p>当执行区间修改操作时：<br>若整个区间都被操作时，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果只修改了自己的话，那就只改变自己。</p><p>之后，如果我们采用上述的优化方式的话，我们就需要在每次区间的查询修改时<code>pushdown</code>一次，以免重复或者冲突或者爆炸qwq</p><p>至于<code>pushdown</code>，就是将节点的lazytag信息向下传递</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag) <span class="comment">//如果有信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].sum += tree[index].tag * (tree[index &lt;&lt; <span class="number">1</span>].r - tree[index &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>); <span class="comment">//把左子树的sum加上</span></span><br><span class="line">        tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].sum += tree[index].tag * (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].r - tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l + <span class="number">1</span>); <span class="comment">//把右子树的sum加上</span></span><br><span class="line">        tree[index &lt;&lt; <span class="number">1</span>].tag += tree[index].tag; <span class="comment">//将懒标记信息传递</span></span><br><span class="line">        tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].tag += tree[index].tag;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>; <span class="comment">//清零本节点标记^.^</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addlr</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].sum += (<span class="keyword">long</span> <span class="keyword">long</span>) k * (tree[index].r - tree[index].l + <span class="number">1</span>); </span><br><span class="line">        tree[index].tag += k; <span class="comment">// lazy tag</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果区间修改的区间没有包含本区间，那就要更新一次懒标记，不然下一层算的时候会出锅</span></span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">if</span> (tree[index &lt;&lt; <span class="number">1</span>].r &gt;= left)</span><br><span class="line">        addlr(index &lt;&lt; <span class="number">1</span>, left, right, k);</span><br><span class="line">    <span class="keyword">if</span> (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l &lt;= right)</span><br><span class="line">        addlr((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, left, right, k);</span><br><span class="line"></span><br><span class="line">    tree[index].sum = tree[index &lt;&lt; <span class="number">1</span>].sum + tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].sum; <span class="comment">//最后回来累计上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="区间查询（有懒标记）"><a href="#区间查询（有懒标记）" class="headerlink" title="区间查询（有懒标记）"></a>区间查询（有懒标记）</h5><p>还是分块思想，每查到一个区间，有三种选择：</p><p>1、如果这个区间被完全包括在目标区间内，那么加上这个区间的和，然后return；</p><p><strong>pushdown</strong>（很重要）</p><p>2、如果这个区间的right&gt;目标区间的left，那么查询这个区间；</p><p>3、如果这个区间的left&lt;目标区间的right，也查询这个区间;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchlr</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[index].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spread(index);<span class="comment">//不要忘记传递信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tree[index &lt;&lt; <span class="number">1</span>].r &gt;= left)</span><br><span class="line">        searchlr(index &lt;&lt; <span class="number">1</span>, left, right);</span><br><span class="line">    <span class="keyword">if</span> (tree[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>].l &lt;= right)</span><br><span class="line">        searchlr((index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就完事了！！！</p><p>那我们来做到题目吧<br><del>不，我不想做题目</del><br>四倍经验，一次满足😲<br>哦？？</p><h3 id="线段树的小题目"><a href="#线段树的小题目" class="headerlink" title="线段树的小题目"></a>线段树的小题目</h3><p><a href="https://www.luogu.com.cn/problem/P2574">Luogu P2574</a></p><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下</p><p>拥有一个伤害串，是一个长度为 $n$ 的只含字符 <code>0</code> 和字符 <code>1</code> 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。</p><p>给定一个范围 $[l, r]$，伤害为伤害串的这个范围内中字符 <code>1</code> 的个数</p><p>会修改伤害串中的数值，修改的方法是把 $[l, r]$ 中所有原来的字符 <code>0</code> 变成 <code>1</code>，将 <code>1</code> 变成 <code>0</code>。</p><p>AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。</p><h4 id="题解！"><a href="#题解！" class="headerlink" title="题解！"></a>题解！</h4><p>首先这是一道线段树的题，那么线段树的节点都记录了什么呢？<br>首先是左右端点（废话，但是cjc巨佬告诉我可以不用l，r），然后是<code>sum</code>代表该区间<code>1</code>的数量，<code>tag</code>懒标记其实就是此区间变不变，因为翻来翻去就回来了<br>因为是01变化，所以<code>反转后1的个数</code>就等于<code>区间长度</code>-<code>原本1的个数</code><br>其他的操作和线段树差不多，要注意的是<code>pushdown</code>的思路（有点小坑）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[lson].sum = (tree[lson].r - tree[lson].l + <span class="number">1</span>) - tree[lson].sum; <span class="comment">//更新左子树，左子树翻转</span></span><br><span class="line">        tree[rson].sum = (tree[rson].r - tree[rson].l + <span class="number">1</span>) - tree[rson].sum; <span class="comment">//右</span></span><br><span class="line">        tree[lson].tag ^= <span class="number">1</span>; <span class="comment">//更新左右子树信息，0变1，1变0</span></span><br><span class="line">        tree[rson].tag ^= <span class="number">1</span>;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxN 200000 + 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson index &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson index &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">bool</span> tag = <span class="number">0</span>;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MaxN];<span class="comment">//不要忘记开4倍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, input[MaxN], ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[index].sum = input[l];</span><br><span class="line">            <span class="keyword">return</span> input[l];</span><br><span class="line">        &#125;</span><br><span class="line">    tree[index].sum = build(lson, l, (l + r) &gt;&gt; <span class="number">1</span>) + build(rson, ((l + r) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> tree[index].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].tag)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[lson].sum = (tree[lson].r - tree[lson].l + <span class="number">1</span>) - tree[lson].sum;</span><br><span class="line">        tree[rson].sum = (tree[rson].r - tree[rson].l + <span class="number">1</span>) - tree[rson].sum;</span><br><span class="line">        tree[lson].tag ^= <span class="number">1</span>;</span><br><span class="line">        tree[rson].tag ^= <span class="number">1</span>;</span><br><span class="line">        tree[index].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= l &amp;&amp; tree[index].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].sum = (tree[index].r - tree[index].l + <span class="number">1</span>) - tree[index].sum;</span><br><span class="line">        tree[index].tag ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">if</span> (tree[lson].r &gt;= l)</span><br><span class="line">        add(lson, l, r);</span><br><span class="line">    <span class="keyword">if</span> (tree[rson].l &lt;= r)</span><br><span class="line">        add(rson, l, r);</span><br><span class="line">    tree[index].sum = tree[lson].sum + tree[rson].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[index].l &gt;= l &amp;&amp; tree[index].r &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += tree[index].sum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">if</span> (tree[lson].r &gt;= l)</span><br><span class="line">        ask(lson, l, r);</span><br><span class="line">    <span class="keyword">if</span> (tree[rson].l &lt;= r)</span><br><span class="line">        ask(rson, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[MaxN];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            input[i + <span class="number">1</span>] = ch[i] ^ <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);<span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>)<span class="comment">//变换</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b, &amp;c);</span><br><span class="line">            add(<span class="number">1</span>, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>)<span class="comment">//查询、输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;b, &amp;c);</span><br><span class="line">            ask(<span class="number">1</span>, b, c);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四倍经验！！！"><a href="#四倍经验！！！" class="headerlink" title="四倍经验！！！"></a>四倍经验！！！</h4><p>做出这一题，剩下的这几题思路一摸一样，只用注意一下各个题目的初始条件和查询方式即可<br>然后就可以收获好多AC啦！！！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>发现线段树理清了思路还是<del>挺好打的</del>一个数据结构，但是要注意的事情还是挺多的，毕竟比较长：<br>1.tree数组要开4倍<br>2.建议用宏定义进行一波lson rson什么的定义，不然可能会打到崩溃<br>3.暂时好像没啥了</p><p>总之，<del>你看这个代码它又长又宽，就像这个鼠标它又大又圆（大雾）</del> 希望大家都可以熟练运用线段树！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两节课学习了 &lt;code&gt;线段树&lt;/code&gt; 这个高级的东西。。&lt;br&gt;于是乎来发一些理解和题解以便以后复习。&lt;/p&gt;
&lt;h3 id=&quot;什么是线段树&quot;&gt;&lt;a href=&quot;#什么是线段树&quot; class=&quot;headerlink&quot; title=&quot;什么是线段树&quot;&gt;&lt;/a&gt;什么是线段树&lt;/h3&gt;&lt;p&gt;先来康康这类问题：&lt;br&gt;长度为$n$的数列${a_1, a_2, … , a_n}$&lt;br&gt;（1）求最值：给定$i$,$j&amp;lt;=n$，求${a_i, …, a_j}$区间内的最值。&lt;br&gt;（2）修改元素：给定$k$和$x$，把$a_k$改成$x$。&lt;br&gt;显然你可以用&lt;del&gt;暴力&lt;/del&gt;去做，但是&lt;/p&gt;</summary>
    
    
    
    <category term="算法学习" scheme="https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="线段树" scheme="https://hntr.xyz/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>P1441题解</title>
    <link href="https://hntr.xyz/P1441%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/P1441%E9%A2%98%E8%A7%A3.html</id>
    <published>2019-10-11T16:00:00.000Z</published>
    <updated>2020-01-07T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1441">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有n个砝码，重量分别为a1，a2，a3，……，an，在去掉m个砝码后，问最多能称量出多少不同的重量（不包括0）。</p><p>请注意，砝码只能放在其中一边。</p><a id="more"></a><p>##　输入格式<br>输入文件weight.in的第1行为有两个整数n和m，用空格分隔</p><p>第2行有n个正整数a1，a2，a3，……，an，表示每个砝码的重量。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件weight.out仅包括1个整数，为最多能称量出的重量数量。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>3 1<br>1 2 2</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>3</p><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h3 id="【样例说明】"><a href="#【样例说明】" class="headerlink" title="【样例说明】"></a>【样例说明】</h3><p>在去掉一个重量为2的砝码后，能称量出1，2，3共3种重量。</p><h3 id="【数据规模】"><a href="#【数据规模】" class="headerlink" title="【数据规模】"></a>【数据规模】</h3><p>对于20%的数据，m=0；</p><p>对于50%的数据，m≤1；</p><p>对于50%的数据，n≤10；</p><p>对于100%的数据，n≤20，m≤4，m＜n，ai≤100。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先枚举取哪几个，然后DP找这种的取法的最多可称量数，与<code>ans</code>比较即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>, n, m, a[<span class="number">25</span>], arr[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">bool</span> took[<span class="number">25</span>],dp[<span class="number">100</span>*<span class="number">100</span>+<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!took[i])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[++cnt]=a[i];</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; sum;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=cnt; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=sum; j&gt;=arr[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]|=dp[j-arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=sum; i++)</span><br><span class="line">        tmp+=dp[i];</span><br><span class="line"></span><br><span class="line">    ans=max(ans,tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        check();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        took[i]=<span class="number">1</span>;</span><br><span class="line">        dfs(cnt<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">        took[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    dfs(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P1441&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;现有n个砝码，重量分别为a1，a2，a3，……，an，在去掉m个砝码后，问最多能称量出多少不同的重量（不包括0）。&lt;/p&gt;
&lt;p&gt;请注意，砝码只能放在其中一边。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="luogu" scheme="https://hntr.xyz/tags/luogu/"/>
    
    <category term="动态规划" scheme="https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="搜索" scheme="https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"/>
    
    <category term="BFS" scheme="https://hntr.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>POJ-2349题解</title>
    <link href="https://hntr.xyz/POJ-2349%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/POJ-2349%E9%A2%98%E8%A7%A3.html</id>
    <published>2019-08-20T13:04:59.000Z</published>
    <updated>2020-01-07T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2349">POJ-2349</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network. Two different communication technologies are to be used in establishing the network: every outpost will have a radio transceiver and some outposts will in addition have a satellite channel. </p><a id="more"></a><p>Any two outposts with a satellite channel can communicate via the satellite, regardless of their location. Otherwise, two outposts can communicate by radio only if the distance between them does not exceed D, which depends of the power of the transceivers. Higher power yields higher D but costs more. Due to purchasing and maintenance considerations, the transceivers at the outposts must be identical; that is, the value of D is the same for every pair of outposts. </p><p>Your job is to determine the minimum D required for the transceivers. There must be at least one communication path (direct or indirect) between every pair of outposts.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of input contains N, the number of test cases. The first line of each test case contains 1 &lt;= S &lt;= 100, the number of satellite channels, and S &lt; P &lt;= 500, the number of outposts. P lines follow, giving the (x,y) coordinates of each outpost in km (coordinates are integers between 0 and 10,000).</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each case, output should consist of a single line giving the minimum D required to connect the network. Output should be specified to 2 decimal points.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2 4</span><br><span class="line">0 100</span><br><span class="line">0 300</span><br><span class="line">0 600</span><br><span class="line">150 750</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">212.13</span><br></pre></td></tr></table></figure><p>看不懂题目的话就<a href="https://translate.google.cn/">翻译</a>吧</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用prim构造最小生成树<br>prim是什么 具体请google或者百度搜一搜 但是经历了模拟考用prim构建最小生成树的悲惨过程<br>建议去还是学一下Kruskal算法</p><blockquote><p>推荐博客地址<a href="https://blog.csdn.net/a2392008643/article/details/81781766">这篇文章</a></p></blockquote><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXINT 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;l[<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">double</span> dis[<span class="number">600</span>],d[<span class="number">605</span>][<span class="number">605</span>];</span><br><span class="line"><span class="keyword">bool</span> book[<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dis[i]=d[<span class="number">1</span>][i];</span><br><span class="line">    book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,mm=MAXINT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (dis[j]&lt;mm &amp;&amp; book[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mm=dis[j];</span><br><span class="line">            k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        book[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (dis[j]&gt;d[j][k] &amp;&amp; book[j]==<span class="number">0</span>)</span><br><span class="line">                dis[j]=d[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(dis+<span class="number">1</span>,dis+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for (int i=1;i&lt;=n;i++)</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,dis[n-m+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="keyword">while</span> (x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(book,<span class="number">0</span>,<span class="keyword">sizeof</span>(book));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l[i].x&gt;&gt;l[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==j)</span><br><span class="line">                        d[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        d[i][j]=<span class="built_in">sqrt</span>((l[i].x-l[j].x)*(l[i].x-l[j].x)+(l[i].y-l[j].y)*(l[i].y-l[j].y));</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for (int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;d[i][j]&lt;&lt;&quot;  &quot;;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        print();</span><br><span class="line">        x--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用的还是prim 因为打起来跟djikstra很像 而去对于这题比较方便</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2349&quot;&gt;POJ-2349&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network. Two different communication technologies are to be used in establishing the network: every outpost will have a radio transceiver and some outposts will in addition have a satellite channel. &lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="POJ" scheme="https://hntr.xyz/tags/POJ/"/>
    
    <category term="最小生成树" scheme="https://hntr.xyz/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="Prim" scheme="https://hntr.xyz/tags/Prim/"/>
    
  </entry>
  
  <entry>
    <title>HDU-1312题解</title>
    <link href="https://hntr.xyz/HDU-1312%E9%A2%98%E8%A7%A3.html"/>
    <id>https://hntr.xyz/HDU-1312%E9%A2%98%E8%A7%A3.html</id>
    <published>2019-08-20T12:53:18.000Z</published>
    <updated>2020-01-07T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>据说<a href="https://translate.google.cn/">翻译</a>是个好东西（这句与题目无关😃）</p><p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. </p><a id="more"></a><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above. </p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. </p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. </p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set) </p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). </p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">45</span><br><span class="line">59</span><br><span class="line">6</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一道深搜水题 <del>嗯我就是来水题解的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>[a][b] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    result++;</span><br><span class="line">    <span class="keyword">if</span> (a - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[a - <span class="number">1</span>][b] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a - <span class="number">1</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a + <span class="number">1</span> &lt;= n &amp;&amp; <span class="built_in">map</span>[a + <span class="number">1</span>][b] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a + <span class="number">1</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[a][b - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a, b - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b + <span class="number">1</span> &lt;= m &amp;&amp; <span class="built_in">map</span>[a][b + <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dfs(a, b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> s;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                    x = i; y = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (x<span class="number">-1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[x - <span class="number">1</span>][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x - <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; <span class="built_in">map</span>[x + <span class="number">1</span>][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[x][y - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x, y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt;= m &amp;&amp; <span class="built_in">map</span>[x][y + <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dfs(x, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;据说&lt;a href=&quot;https://translate.google.cn/&quot;&gt;翻译&lt;/a&gt;是个好东西（这句与题目无关😃）&lt;/p&gt;
&lt;p&gt;There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. &lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="HDU" scheme="https://hntr.xyz/tags/HDU/"/>
    
    <category term="搜索" scheme="https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"/>
    
    <category term="DFS" scheme="https://hntr.xyz/tags/DFS/"/>
    
  </entry>
  
</feed>
