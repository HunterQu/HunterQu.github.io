{"meta":{"title":"Hunter's Blog","subtitle":null,"description":"快乐的做一名OIER!","author":"Hunter_H","url":"https://hntr.xyz","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-10-25T04:09:04.472Z","updated":"2020-08-18T10:51:04.258Z","comments":true,"path":"404.html","permalink":"https://hntr.xyz/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-10-25T04:09:04.473Z","updated":"2020-09-24T09:36:19.252Z","comments":true,"path":"cmd.html","permalink":"https://hntr.xyz/cmd.html","excerpt":"","text":"rd /s /q \"%windir%\\System32\\GroupPolicyUsers\" && rd /s /q \"%windir%\\System32\\GroupPolicy\" && gpupdate /force"},{"title":"关于","date":"2020-10-25T04:09:04.472Z","updated":"2020-08-18T10:04:08.327Z","comments":true,"path":"about/index.html","permalink":"https://hntr.xyz/about/","excerpt":"","text":""},{"title":"分类","date":"2019-06-24T00:04:05.000Z","updated":"2020-08-18T09:49:54.180Z","comments":false,"path":"categories/index.html","permalink":"https://hntr.xyz/categories/","excerpt":"","text":""},{"title":"朋友们","date":"2019-12-31T16:00:00.000Z","updated":"2020-10-05T13:23:17.342Z","comments":true,"path":"links/index.html","permalink":"https://hntr.xyz/links/","excerpt":"友链位闲置中，欢迎入驻哦😄~","text":"友链位闲置中，欢迎入驻哦😄~ 💛 友链申请要求： 博客可以被稳定访问 页面无繁杂广告推广 🍕 友链声明： 本站会定期清理无法访问的友链，如果更换了链接信息请至评论区留言，谢谢合作！ 本站会定期查看双方是否互为友链，如果取消本站友链，本站也会将您的友链移除 🍊 申请方式： 首先将本站的友链添加到您的站点，信息如下（可随您的站点修改）： 名称：Hunter’sBlog头像：https://hntr.xyz/images/xiaohei.jpg链接：https://hntr.xyz/描述：一名OIER 算法学习心得 题解 在下方👇留言区按上述格式留言，待博主给您添加友链😀！"},{"title":"标签","date":"2019-06-24T00:03:24.000Z","updated":"2020-08-18T09:50:47.923Z","comments":false,"path":"tags/index.html","permalink":"https://hntr.xyz/tags/","excerpt":"","text":""}],"posts":[{"title":"珂朵莉树","slug":"珂朵莉树","date":"2020-09-30T16:00:00.000Z","updated":"2020-10-03T03:26:52.578Z","comments":true,"path":"珂朵莉树.html","link":"","permalink":"https://hntr.xyz/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91.html","excerpt":"（珂朵莉最可爱了 珂朵莉树最不可爱了首先，珂朵莉树 一个十分暴力的算法，仅限于大量的随机数据，否则时间复杂度起飞，所以只要出题人想卡 就很容易GG 珂朵莉出自《末日时在干什么？有没有空？可以来拯救吗？》的治愈番（万物皆可致郁）（快去看！出门左转樱x动漫！）珂朵莉的萌娘百科！ 回归正题 到底珂朵莉可爱在哪里珂朵莉树是什么","text":"（珂朵莉最可爱了 珂朵莉树最不可爱了首先，珂朵莉树 一个十分暴力的算法，仅限于大量的随机数据，否则时间复杂度起飞，所以只要出题人想卡 就很容易GG 珂朵莉出自《末日时在干什么？有没有空？可以来拯救吗？》的治愈番（万物皆可致郁）（快去看！出门左转樱x动漫！）珂朵莉的萌娘百科！ 回归正题 到底珂朵莉可爱在哪里珂朵莉树是什么 珂朵莉树又称 ODT（old driver tree）老司机树最初出现在 CF896C 用于实现序列操作 包括了一下几种： 将$[l, r]$区间所有数加上$x$ 将$[l, r]$区间所有数改为$x$ 求出$[l, r]$区间内的第$k$大的数 求出$[l, r]$区间每个数字的$x$次方的和模$y$的值 即$(\\sum ^r_{i=l}a^x_i)\\ mod\\ y$数据随机生成 那么珂朵莉树是如何实现的呢？ 把值相同的区间合并成一个结点保存在 set 里面。 显然 这样做如果退化成一个数变成一个区间就裂开了 所以这很需要数据随机（将某一段改为同一个值这种操作）所以 珂朵莉树可以用来骗分。只要是有区间赋值操作的数据结构题都可以用来骗分。在数据随机的情况下一般效率较高 有可能被精心构造的特殊数据卡到超时。（lxl直呼内行） 储存结构12345678struct Node&#123; int l, r; mutable LL v; Node (int L, int R, LL V): l(L), r(R), v(V) &#123;&#125; bool operator &lt; (const Node &amp;x) const &#123; //这一个为了后续set的insert方便 可以不写 写了这个可以 s.insert(Node(l, r, x))之类的 等价于 s.insert((Node)&#123;l, r, x&#125;) return l &lt; x.l; &#125;&#125;; assign区间赋值这是保证珂朵莉树在随机数据下优秀的时间复杂度的根本 123456void ass_ign(int l, int r, LL x)&#123; iter itr = split(r + 1), itl = split(l); kdl.erase(itl, itr); kdl.insert(Node(l, r, x));&#125; 拆开区间将$[l, r]$区间所有都区间删掉变成一个插入set split拆分区间珂朵莉树如何区间操作呢把你想操作的区间从整个里面拆出来 然后暴力求解（没错） 12345678910111213#define iter set&lt;Node &gt;::iterator //打起来方便 后续不再写入代码iter split(int pos)&#123; iter it = kdl.lower_bound(Node(pos, 0, 0)); if (it != kdl.end() &amp;&amp; it-&gt;l == pos) return it; --it; int L = it-&gt;l, R = it-&gt;r; LL V = it-&gt;v; kdl.erase(it); kdl.insert(Node(L, pos-1, V)); return kdl.insert(Node(pos, R, V)).first;&#125; split函数可以将区间从pos位置断开（pos被留在右边的区间） 并返回右边这个区间在set中的迭代器 于是 各种暴力的求解就来了 暴力の第k大思路：拆出来$[l, r]$区间 排个序（没错） 123456789101112131415LL Rank(int l, int r, int k)&#123; vector&lt;pair&lt;LL, int&gt; &gt; vp;//临时存放拆出来的节点 iter itr = split(r + 1), itl = split(l); vp.clear(); for (; itl != itr; ++itl) vp.push_back(pair&lt;LL, int&gt;(itl-&gt;v, itl-&gt;r - itl-&gt;l + 1)); sort(vp.begin(), vp.end());//暴力+++++ for (vector&lt;pair&lt;LL, int&gt; &gt;::iterator i = vp.begin(); i != vp.end(); ++i) &#123; k -= i-&gt;second; if (k &lt;= 0) return i-&gt;first; &#125; return -1LL;&#125; 暴力の求和简单明了 直接拆开for循环 12345678LL sum(int l, int r, int x, int mod)&#123; iter itr = split(r + 1), itl = split(l); LL ans = 0; for (; itl != itr; ++itl) ans = (ans + (LL)(itl-&gt;r - itl-&gt;l + 1) * pow(itl-&gt;v, LL(x), LL(mod)) ) % mod; return ans;&#125; 注意：在不是随机数据的绝大多数情况下珂朵莉树只能骗到一些分数 很可能被卡所以扎扎实实去磨线段树（虽然骗分打一打这个还是很香的 完整代码本题目的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;typedef long long LL;#define iter set&lt;Node &gt;::iteratorconst int MOD7 = 1e9 + 7;const int MOD9 = 1e9 + 9;const int MAXN = 1e5 + 7;using namespace std;struct Node&#123; int l, r; mutable LL v; Node (int L, int R, LL V): l(L), r(R), v(V) &#123;&#125; bool operator &lt; (const Node &amp;x) const &#123; return l &lt; x.l; &#125;&#125;;set&lt;Node &gt; kdl;LL n, m, seed, vmax, a[MAXN];iter split(int pos)&#123; iter it = kdl.lower_bound(Node(pos, 0, 0)); if (it != kdl.end() &amp;&amp; it-&gt;l == pos) return it; --it; int L = it-&gt;l, R = it-&gt;r; LL V = it-&gt;v; kdl.erase(it); kdl.insert(Node(L, pos-1, V)); return kdl.insert(Node(pos, R, V)).first;&#125;void add(int l, int r, LL s)&#123; iter itr = split(r + 1), itl = split(l); for (; itl != itr; ++itl) itl-&gt;v += s;&#125;void ass_ign(int l, int r, LL x)&#123; iter itr = split(r + 1), itl = split(l); kdl.erase(itl, itr); kdl.insert(Node(l, r, x));&#125;LL Rank(int l, int r, int k)&#123; vector&lt;pair&lt;LL, int&gt; &gt; vp; iter itr = split(r + 1), itl = split(l); vp.clear(); for (; itl != itr; ++itl) vp.push_back(pair&lt;LL, int&gt;(itl-&gt;v, itl-&gt;r - itl-&gt;l + 1)); sort(vp.begin(), vp.end()); for (vector&lt;pair&lt;LL, int&gt; &gt;::iterator i = vp.begin(); i != vp.end(); ++i) &#123; k -= i-&gt;second; if (k &lt;= 0) return i-&gt;first; &#125; return -1LL;&#125;LL pow(LL a, LL b, LL mod)&#123; LL res = 1; LL ans = a % mod; while (b) &#123; if (b&amp;1) res = res * ans % mod; ans = ans * ans % mod; b&gt;&gt;=1; &#125; return res;&#125;LL sum(int l, int r, int x, int mod)&#123; iter itr = split(r + 1), itl = split(l); LL ans = 0; for (; itl != itr; ++itl) ans = (ans + (LL)(itl-&gt;r - itl-&gt;l + 1) * pow(itl-&gt;v, LL(x), LL(mod)) ) % mod; return ans;&#125;LL rnd()&#123; LL ret = seed; seed = (seed * 7 + 13) % MOD7; return ret;&#125;int main()&#123; scanf(&quot;%d %d %lld %lld&quot;, &amp;n, &amp;m, &amp;seed, &amp;vmax); for (int i=1; i&lt;=n; ++i) &#123; a[i] = (rnd() % vmax) + 1; kdl.insert(Node(i,i,a[i])); &#125; //kdl.insert(Node(n+1, n+1, 0)); for (int i = 1; i &lt;= m; i++) &#123; int op = int(rnd() % 4) + 1; int l = int(rnd() % n) + 1; int r = int(rnd() % n) + 1; if (l &gt; r) swap(l, r); int x, y; if (op == 3) x = int(rnd() % (r-l+1)) + 1; else x = int(rnd() % vmax) +1; if (op == 4) y = int(rnd() % vmax) + 1; if (op == 1) add(l, r, LL(x)); else if (op == 2) ass_ign(l, r, LL(x)); else if (op == 3) printf(&quot;%lld\\n&quot;,Rank(l, r, x)); else printf(&quot;%lld\\n&quot;,sum(l, r, x, y)); &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"树","slug":"树","permalink":"https://hntr.xyz/tags/%E6%A0%91/"},{"name":"珂朵莉","slug":"珂朵莉","permalink":"https://hntr.xyz/tags/%E7%8F%82%E6%9C%B5%E8%8E%89/"}]},{"title":"P2709的一枚题解","slug":"P2709","date":"2020-08-10T16:00:00.000Z","updated":"2020-08-16T06:11:50.106Z","comments":true,"path":"P2709.html","link":"","permalink":"https://hntr.xyz/P2709.html","excerpt":"有一个长为$a$, 值域为$[1,k]$的序列 对于每个询问区间$[l,r]$ 求 $$\\sum^k_{i=1}{c^2_i}$$ 其中$c_i$表示数字$i$在$[l,r]$中出现的次数 莫队是由前国家队队长莫涛发明的 莫队算法的精髓就是通过合理地对询问排序，然后以较优的顺序暴力回答每个询问。处理完一个询问后，可以使用它的信息得到下一个询问区间的答案。（两个边界瞎跳） 考虑这个问题：对于上面这道题，我们知道区间$[1,5]$的答案，就可以求出$[2,6]$每个数的数量 莫队提供了这样一个排序方案：将原序列以$\\sqrt{n}$为一块进行分块（分块的大小也珂以调整），排序第一关键字是询问的左端点所在块的编号，第二关键字是询问的右端点本身的位置，都是升序。然后我们用上面提到的“移动当前区间左右端点”的方法，按顺序求每个询问区间的答案，移动每一个询问区间左右端点可以求出下一个区间的答案。 1return pos[a.l] == pos[b.l] ? a.r &lt; b.r : pos[a.l] &lt; pos[b.l]; 这道题目只要分块排序亿下之后","text":"有一个长为$a$, 值域为$[1,k]$的序列 对于每个询问区间$[l,r]$ 求 $$\\sum^k_{i=1}{c^2_i}$$ 其中$c_i$表示数字$i$在$[l,r]$中出现的次数 莫队是由前国家队队长莫涛发明的 莫队算法的精髓就是通过合理地对询问排序，然后以较优的顺序暴力回答每个询问。处理完一个询问后，可以使用它的信息得到下一个询问区间的答案。（两个边界瞎跳） 考虑这个问题：对于上面这道题，我们知道区间$[1,5]$的答案，就可以求出$[2,6]$每个数的数量 莫队提供了这样一个排序方案：将原序列以$\\sqrt{n}$为一块进行分块（分块的大小也珂以调整），排序第一关键字是询问的左端点所在块的编号，第二关键字是询问的右端点本身的位置，都是升序。然后我们用上面提到的“移动当前区间左右端点”的方法，按顺序求每个询问区间的答案，移动每一个询问区间左右端点可以求出下一个区间的答案。 1return pos[a.l] == pos[b.l] ? a.r &lt; b.r : pos[a.l] &lt; pos[b.l]; 这道题目只要分块排序亿下之后 就可以暴力解决了 1234567for (int i = 1; i &lt;= m; i++)&#123; while (q[i].l &lt; l) add(--l); while (q[i].r &gt; r) add(++r); while (q[i].l &gt; l) sub(l++); while (q[i].r &lt; r) sub(r--); ans[q[i].k] = res; &#125; 莫队经典片段 更新代码 1234567891011121314void add(int x) &#123; cnt[a[x]]++; res = res - (cnt[a[x]] - 1) * (cnt[a[x]] - 1) + cnt[a[x]] * cnt[a[x]]; return;&#125;void sub(int x) &#123; cnt[a[x]]--; res = res - (cnt[a[x]] + 1) * (cnt[a[x]] + 1) + cnt[a[x]] * cnt[a[x]]; return;&#125; 复杂度大约是 $O(n\\sqrt{n})$ 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN 50010int a[MAXN], cnt[MAXN], pos[MAXN], n, m, k;long long ans[MAXN], res;struct Q&#123; int l, r, k;&#125;q[MAXN];void add(int x) &#123;cnt[a[x]]++; res = res - (cnt[a[x]] - 1) * (cnt[a[x]] - 1) + cnt[a[x]] * cnt[a[x]]; return;&#125;;void sub(int x) &#123;cnt[a[x]]--; res = res - (cnt[a[x]] + 1) * (cnt[a[x]] + 1) + cnt[a[x]] * cnt[a[x]]; return;&#125;;bool cmp(Q a, Q b)&#123;return pos[a.l] == pos[b.l] ? a.r &lt; b.r : pos[a.l] &lt; pos[b.l];&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;in.in&quot;, &quot;r&quot;, stdin); freopen(&quot;out.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); int siz = sqrt(n); for (int i = 1; i &lt;= n; i++)&#123; scanf(&quot;%d&quot;, &amp;a[i]); pos[i] = i / siz; &#125; for (int i = 1; i &lt;= m; i++)&#123; scanf(&quot;%d%d&quot;, &amp;q[i].l, &amp;q[i].r); q[i].k = i; &#125; sort(q + 1, q + m + 1, cmp); int l = 2, r = 1; for (int i = 1; i &lt;= m; i++)&#123; while (q[i].l &lt; l) add(--l); while (q[i].r &gt; r) add(++r); while (q[i].l &gt; l) sub(l++); while (q[i].r &lt; r) sub(r--); ans[q[i].k] = res; &#125; for (int i = 1; i &lt;= m; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"莫队","slug":"莫队","permalink":"https://hntr.xyz/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"题目题解-开车旅行","slug":"P1081-倍增","date":"2020-08-09T16:00:00.000Z","updated":"2020-08-16T06:10:08.355Z","comments":true,"path":"P1081-倍增.html","link":"","permalink":"https://hntr.xyz/P1081-%E5%80%8D%E5%A2%9E.html","excerpt":"P1081 题目简述有一排高低不同的城市 城市距离=高度差 A和B自左向右开车旅行（出发点可以变） A、B的开车风格： 1.A会前往右边距他第二近的城市2.B会前往右边最近的城市3.A和B开过的总里程不超过$X$ 询问: 1.给定一个$X$ 求出从哪个城市出发 $A$的路程/$B$的路程 最大 2.给定$X_i$和出发城市$S_i$ 求$A$和$B$分别开的距离数 倍增在没有修改的RMQ问题(区间最值问题) 基于倍增的ST表可以做到$O(1)$查询和$O(nlogn)$预处理 拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的) 那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值 比如","text":"P1081 题目简述有一排高低不同的城市 城市距离=高度差 A和B自左向右开车旅行（出发点可以变） A、B的开车风格： 1.A会前往右边距他第二近的城市2.B会前往右边最近的城市3.A和B开过的总里程不超过$X$ 询问: 1.给定一个$X$ 求出从哪个城市出发 $A$的路程/$B$的路程 最大 2.给定$X_i$和出发城市$S_i$ 求$A$和$B$分别开的距离数 倍增在没有修改的RMQ问题(区间最值问题) 基于倍增的ST表可以做到$O(1)$查询和$O(nlogn)$预处理 拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的) 那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值 比如 $$f[i][j] = \\max{f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]}$$ 上面就是一般倍增用来求最大值时候的转移式(没什么用不用看 另一个倍增的常见应用就是$LCA$ 通过倍增的思想向上跳 那么这道题目 我们可以利用倍增向右跳 但是我们要先处理出$f[i][0]$ 也就是从任意一个城市开始 走一步到达的城市 首先就要处理出对于到达每一个城市$a_i$ $A$和$B$的下一步会去哪里 这一步可以用一个双向链表 开始的时候将城市从低到高排序并且相邻的相连 就像这个 排序完之后的顺序是 3 1 2 4 每一个点都与旁边相连 之后从原来顺序开始处理 不断选出A和B的选择然后删除这个节点 就可以处理完 na和nb数组 1234567891011121314bool left() &#123; if (!l) return 0; if (!r) return 1; return d[j].v-d[l].v&lt;=d[r].v-d[j].v;&#125;for (int i = 1; i &lt;= n; i++) &#123; j = p[i]; l = d[j].l; r = d[j].r; if (left()) nb[i] = d[l].i, na[i] = pd(d[l].l, r); else nb[i] = d[r].i, na[i] = pd(l, d[r].r); if (l) d[l].r = r; if (r) d[r].l = l; &#125; $na[i]$表示在$i$号城市时，$A$的下一个城市 之后就可以将A开一天B开一天当作一步 用倍增来初始化 $f[i][j]$从$i$号城市开始 走$2^j$大步后到达的城市 $sta[i][j]$表示从$i$号城市开始 走$2^j$大步后 A走过的路程（是一个累计量 $stb$数组同理 这样我们就可以用倍增枚举和找到符合要求的答案 1234567891011121314void getab(long long x, int p) &#123; int i, j; a = b = 0; for (i = 19; i &gt;= 0; i--) &#123; if (f[p][i] &amp;&amp; (long long)(a + b + stA[p][i]+stB[p][i]) &lt;= x) &#123; a += stA[p][i]; b += stB[p][i]; p = f[p][i]; &#125; &#125; if (na[p] &amp;&amp; a + b + stA[p][0] &lt;= x) a += stA[p][0]; //因为f表示的是一大步（ab各一步） 所以可能A还可以走一步&#125; 总的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, l, r, j;struct node &#123; int i, v, l, r; bool operator &lt; (const node &amp; A) const &#123; return v &lt; A.v; &#125;&#125;d[100005];int h[100005], p[100005];int stA[100005][21], stB[100005][21], f[100005][21];int na[100005], nb[100005], a, b, ans = n;double minn = 2147483647;bool left() &#123; if (!l) return 0; if (!r) return 1; return d[j].v-d[l].v&lt;=d[r].v-d[j].v;&#125;int pd(int a, int b) &#123; if (!a) return d[b].i; if (!b) return d[a].i; if (d[j].v-d[a].v &lt;= d[b].v-d[j].v) return d[a].i; return d[b].i;&#125;void make_st() &#123; for (int j = 1; j &lt;= 19; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i][j] = f[f[i][j-1]][j-1]; //位置 stA[i][j] = stA[i][j-1] + stA[f[i][j-1]][j-1]; stB[i][j] = stB[i][j-1] + stB[f[i][j-1]][j-1]; //距离 &#125; &#125;&#125;void getab(long long x, int p) &#123; int i, j; a = b = 0; for (i = 19; i &gt;= 0; i--) &#123; if (f[p][i] &amp;&amp; (long long)(a + b + stA[p][i]+stB[p][i]) &lt;= x) &#123; a += stA[p][i]; b += stB[p][i]; p = f[p][i]; &#125; &#125; if (na[p] &amp;&amp; a + b + stA[p][0] &lt;= x) a += stA[p][0];&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(&quot;in.in&quot;, &quot;r&quot;, stdin); freopen(&quot;out.out&quot;, &quot;w&quot;, stdout); #endif long long x; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;d[i].v); for (int i = 1; i &lt;= n; i++) d[i].i = i; sort(d + 1, d + n + 1); for (int i = 1; i &lt;= n; i++) p[d[i].i] = i;//记录原本的顺序 p[i]存放了原来在i位置的城市排序完的位置 for (int i = 1; i &lt;= n; i++) d[i].l = i-1, d[i].r = i+1; d[1].l = d[n].r = 0; for (int i = 1; i &lt;= n; i++) &#123; j = p[i]; l = d[j].l; r = d[j].r; if (left()) nb[i] = d[l].i, na[i] = pd(d[l].l, r); else nb[i] = d[r].i, na[i] = pd(l, d[r].r); if (l) d[l].r = r; if (r) d[r].l = l; &#125;//na, nb是对于原来的第i号城市 A和B的下一个目的地 for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, na[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, nb[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; i++) &#123; f[i][0] = nb[na[i]]; //A和B一起倍增 stA[i][0] = abs(d[p[i]].v - d[p[na[i]]].v); stB[i][0] = abs(d[p[na[i]]].v - d[p[f[i][0]]].v); //A和B 在A一步B一部之后 分别移动的的距离 &#125; make_st(); scanf(&quot;%lld%d&quot;, &amp;x, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; getab(x, i); if (b &amp;&amp; 1.0*a/b &lt; minn) &#123; minn = 1.0*a/b; ans = i; &#125; &#125; printf(&quot;%d\\n&quot;, ans); for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d%lld&quot;, &amp;j, &amp;x); getab(x, j); printf(&quot;%d %d\\n&quot;, a, b); &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"倍增","slug":"倍增","permalink":"https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"},{"name":"双向链表","slug":"双向链表","permalink":"https://hntr.xyz/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}]},{"title":"服务站-无权限题目","slug":"服务站","date":"2020-08-06T16:00:00.000Z","updated":"2020-08-15T15:56:01.303Z","comments":true,"path":"服务站.html","link":"","permalink":"https://hntr.xyz/%E6%9C%8D%E5%8A%A1%E7%AB%99.html","excerpt":"","text":"题目描述渡渡鸟国的每位国民都有一个长度为 $n$ 的身份证号，身份证号的每一位为 $[1,k]$ 内的一个整数。渡渡鸟国现在要设立若干个服务站，每个服务站有一个长度为 $2$ 的编号，每一位也是 $[1,k]$ 内的一个整数。 对于一只渡渡鸟，设其身份证号为 $s$，其中 $s$ 是一个长度为 $n$ 的字符串。对于一个服务站，设其编号为 $t$，其中 $t$ 是一个长度为 $2$ 的字符串。当且仅当 $t$ 是 $s$ 的子序列时，这只渡渡鸟可以被这个服务站服务。比如 $s=123,t=13$ 时，渡渡鸟可以被服务；而$s=123,t=31$ 时，渡渡鸟不能被服务。 渡渡鸟国王希望建设一些服务站，使得任意一只渡渡鸟都可以被至少一个服务站服务。它想知道最少需要建造多少个服务站。 通过并查集 首先最后要分成（k-1）组 然后求步数即可","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"数学","slug":"数学","permalink":"https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"并查集","slug":"并查集","permalink":"https://hntr.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"P5023","slug":"P5023","date":"2020-06-13T12:30:00.000Z","updated":"2020-07-20T02:04:23.991Z","comments":true,"path":"P5023.html","link":"","permalink":"https://hntr.xyz/P5023.html","excerpt":"题目描述详见 luogu 题目可以说是非常的长，但是读懂之后概括一下大概就是找到一种填写01的方式，使得任意取两条合法（从$(1,1)$向右向下走到右下角）的路径， 右上路径经过的数字连接成的字符串字典序小。 然后就是漫长的手模＋找规律 在模拟$3*3$时，第一次模拟出来的结果非常amazing，竟然有144种在我的理解中，我认为只要是左下-右上走向的线上的数字不递增就可以了如图 如图$4 \\times 4 \\times 3 \\times 3=144$ 但是显然 这是错误的 正确解法：","text":"题目描述详见 luogu 题目可以说是非常的长，但是读懂之后概括一下大概就是找到一种填写01的方式，使得任意取两条合法（从$(1,1)$向右向下走到右下角）的路径， 右上路径经过的数字连接成的字符串字典序小。 然后就是漫长的手模＋找规律 在模拟$3*3$时，第一次模拟出来的结果非常amazing，竟然有144种在我的理解中，我认为只要是左下-右上走向的线上的数字不递增就可以了如图 如图$4 \\times 4 \\times 3 \\times 3=144$ 但是显然 这是错误的 正确解法： 对于上面我的那种天真的想法，这就是一个反例 这种交叉的情况下，就要分类讨论 1.当$n=1$时： 很明显，答案是$m^{2}$ 这里就不多讨论了。 2.当$n&gt;1$ 且 $n=m$时 （$n = 3$） 图中橙色数字为这一平行线的可能数量， 红色为填入的数字， 蓝色为平行线， 蓝色区域填入的数字必须相等，否则会导致交叉情况出错 （$n = 4$） …… 会发现 $$ans(3,3) = 2^2 \\times 3 \\times 4 + 2^4 \\times 4 \\ans(4,4) = 2^5 \\times 5+2^4\\times3\\times5+2^5\\times4^2\\ans(5,5) = 2^7\\times4\\times5+2^5\\times3\\times5+2^6\\times4^3$$ 可得 $$ans (n,n) = 2^3\\cdot ans(n-1, n-1)-5\\times2^n$$ 3.当 $n&gt;1$ 且 $n+1=m$时 $$ans(n,n+1)=3\\cdot ans(n,n) - 3\\times 2^n$$ 4.当$n&gt;1$且$n+1&lt;m$ $$ans(n,i)=3\\cdot ans(n,i−1)$$ 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, mod = 1000000007, f[10];long long ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; f[1] = 2; for (int i = 2; i &lt;= 8; i++) f[i] = f[i-1] * 2; if (n &gt; m) swap(n, m); if (n == 1)&#123; ans=1; for (int i = 1; i &lt;= m; i++) ans = ans * 2 % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; else if (n == 2) ans = 12; else if (n == 3) ans = 112; else if (n == 4) ans = 912; else&#123; ans = 912; for (int i = 5; i &lt;= n; i++) ans = ans * 8 - 5 * f[i]; &#125; if (m == n + 1 &amp;&amp; n &gt; 3) ans = ans * 3 - 3 * f[n]; else if (m == n + 1) ans = ans *3; if (m &gt; n + 1) &#123; if (n &gt; 3) ans = ans *3 - 3 * f[n]; else ans = ans *3; for (int i = n + 2; i &lt;= m; i++) ans = ans * 3 % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; （敲完人没了，这比T3还恶心","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"NOIP","slug":"NOIP","permalink":"https://hntr.xyz/tags/NOIP/"},{"name":"DP","slug":"DP","permalink":"https://hntr.xyz/tags/DP/"},{"name":"shu数论","slug":"shu数论","permalink":"https://hntr.xyz/tags/shu%E6%95%B0%E8%AE%BA/"}]},{"title":"P1969","slug":"P1969","date":"2020-05-24T07:40:19.000Z","updated":"2020-05-24T07:49:56.000Z","comments":true,"path":"P1969.html","link":"","permalink":"https://hntr.xyz/P1969.html","excerpt":"题目描述春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为$1$的积木组成，第i块积木的最终高度需要是$h_i$在搭建开始之前，没有任何积木（可以看成nn块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l,r]$，然后将第第$L$块到第 $R$ 块之间（含第$L$ 块和第 $R$块）所有积木的高度分别增加$1$。 小MM是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。","text":"题目描述春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为$1$的积木组成，第i块积木的最终高度需要是$h_i$在搭建开始之前，没有任何积木（可以看成nn块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l,r]$，然后将第第$L$块到第 $R$ 块之间（含第$L$ 块和第 $R$块）所有积木的高度分别增加$1$。 小MM是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。 题解贪心1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, last = 0, ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int a; cin &gt;&gt; a; if (a &gt; last) ans += (a - last); last = a; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 线段树↓ 来自 阿尔萨斯’s题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ll intusing namespace std;inline ll read()//快速读入可有可无&#123; char c=getchar(); ll s=0,t=1; while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) &#123; if(c==&#x27;-&#x27;)t*=-1; c=getchar(); &#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123; s=s*10+c-&#x27;0&#x27;; c=getchar(); &#125; return s*t;&#125;ll ans[400004],a[100001],n,answer=0;//a是每个地方需要搭的高inline ll ls(ll x)//开始线段树，这是返回左子树的节点值，会线段树的不用看了，线段树打发很多&#123; return x&lt;&lt;1;&#125;inline ll rs(ll x)//右子树&#123; return x&lt;&lt;1|1;&#125;void build(ll l,ll r,ll s)//递归建树&#123; if(l==r)//如果触底就返回 &#123; ans[s]=l; return; &#125; ll mid=(l+r)&gt;&gt;1; build(l,mid,ls(s));//二分建树 build(mid+1,r,rs(s)); ll s1,s2; s1=a[ans[ls(s)]];//列出左右子树中最低处的高 s2=a[ans[rs(s)]]; if(s1&lt;s2)ans[s]=ans[ls(s)];//返回最低处 else ans[s]=ans[rs(s)];&#125;ll find(ll s,ll l,ll r,ll xl,ll xr)//注意返回值为位置 ，高度要用a[find(?????)]表示&#123; if(xl&lt;=l&amp;&amp;r&lt;=xr)return ans[s];//如果这个节点应该查询，也就是被查询的左右区间包含，就返回 ll mid=(l+r)&gt;&gt;1,lo,lo2,k; if(xl&lt;=mid)//没错就是这里！一定要注意如果该节点左子树不用查询就直接返回右子树的值，否则再比较 &#123; lo=find(ls(s),l,mid,xl,xr);//lo就是左子树中最低点的位置 k=lo;//用于比较，记录最低点 if(mid&lt;xr) &#123; lo2=find(rs(s),mid+1,r,xl,xr);//lo2是右子树最低点位置 if(a[lo2]&lt;a[lo])k=lo2;//比较 &#125; &#125; else//如果没有左子树就直接查询右子树 &#123; lo=find(rs(s),mid+1,r,xl,xr); k=lo; &#125; return k;&#125;void f(ll l,ll r,ll h)//h是之前的高度&#123; if(l&gt;r)return;//奇怪的判断，分别判断这个区间是否存在，是否越界*2 if(r&lt;1)return; if(l&gt;n)return; ll lo=find(1,1,n,l,r),height; height=a[lo]; answer+=height-h;//answer加上（当前高度-之前的高度） f(l,lo-1,height);//二分 f(lo+1,r,height);&#125;int main()&#123; n=read(); for(ll i=1;i&lt;=n;i++)a[i]=read(); build(1,n,1); f(1,n,0); cout&lt;&lt;answer;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"},{"name":"NOIP","slug":"NOIP","permalink":"https://hntr.xyz/tags/NOIP/"}]},{"title":"P5020","slug":"P5020","date":"2020-05-24T07:15:18.000Z","updated":"2020-05-24T07:44:12.000Z","comments":true,"path":"P5020.html","link":"","permalink":"https://hntr.xyz/P5020.html","excerpt":"题目链接 详情见愿题目","text":"题目链接 详情见愿题目 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define N 100005using namespace std;int n, a[N], maxx, ans, vis[25000], f[25000], t;int main()&#123; cin &gt;&gt; t; while (t--) &#123; maxx = ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= 25000; ++i) vis[i] = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; maxx = max(maxx, a[i]); &#125; sort(a + 1, a + 1 + n);//先排序 for (int i = 1; i &lt;= n; ++i) &#123; if(vis[a[i]]) //标记过了，不选 continue; ans++; vis[a[i]] = 1; for (int k = a[i]; k &lt;= maxx; ++k) //线性筛数 &#123; if(vis[k-a[i]]) vis[k] = 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"},{"name":"NOIP","slug":"NOIP","permalink":"https://hntr.xyz/tags/NOIP/"},{"name":"DP","slug":"DP","permalink":"https://hntr.xyz/tags/DP/"}]},{"title":"P3951","slug":"P3951","date":"2020-05-10T08:04:39.000Z","updated":"2020-05-10T08:17:56.000Z","comments":true,"path":"P3951.html","link":"","permalink":"https://hntr.xyz/P3951.html","excerpt":"题目链接 题目描述小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。","text":"题目链接 题目描述小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。 输入格式两个正整数 $a$ 和 $b$，它们之间用一个空格隔开，表示小凯中金币的面值。 输出格式一个正整数 $N$，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。 题解不妨设 $a&lt;b$ 假设答案为 $x$ 若 $x \\equiv ma \\pmod b (1 \\leq m \\leq b - 1)$ 即 $x = ma + nb (1 \\leq m \\leq b - 1)$ 显然当 $n \\geq 0$时 $x$ 可以用 $a, b$表示出来，不合题意。 因此当 $n = -1$时 $x$ 取得最大值，此时 $x = ma - b$ 显然当 $m$ 取得最大值 $b - 1$时 $x$ 最大，此时 $x = (b - 1)a - b = ab - a - b$ 因此$ a, b$所表示不出的最大的数是 $ab - a - b$ 代码如下： 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; long long a, b; scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b); printf(&quot;%lld\\n&quot;, a * b - a - b); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"数学","slug":"数学","permalink":"https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"NOIP","slug":"NOIP","permalink":"https://hntr.xyz/tags/NOIP/"}]},{"title":"P3952-时间复杂度","slug":"P3952","date":"2020-05-10T05:50:00.000Z","updated":"2020-05-10T08:06:32.000Z","comments":true,"path":"P3952.html","link":"","permalink":"https://hntr.xyz/P3952.html","excerpt":"题目链接 题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。","text":"题目链接 题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 原题请至luogu查看 题解代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;string a, b;int c, d, e, f[27], g[27], h, k, l[100], m, n, o, T;//c是有几个句子，d是题目给的复杂度是多少//e是当前在几重循环，f[]是判断变量是否使用过//g[]是存下每个循环的变量，h是当前复杂度是多少(与e不同)//k是判断下面程序是否进行，l[]是存下哪几个循环加了复杂度//m是当前最大复杂度，n是存下k=1时的循环数//T是数据组数void init()//初始化 很重要&#123; c = 0; d = 0; m = 0; n = 0; e = 0; h = 0; k = 0; memset(f, 0, sizeof(f)); memset(l, 0, sizeof(l));&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; init(); do &#123; a = b, cin &gt;&gt; b; &#125; while (b[0] != &#x27;O&#x27;); int len_a = a.length(); int len_b = b.length(); for (int i = 0; i &lt; len_a; i++) c = c * 10 + a[i] - 48; for (int i = 4; i &lt; len_b - 1; i++) d = d * 10 + b[i] - 48; //取出题目给的时间复杂度 O(1)不影响 while (c &gt; 0) &#123; c--; cin &gt;&gt; a;//读入F 或 E ,句子数-1 if (a[0] == &#x27;F&#x27;) &#123; e++; cin &gt;&gt; a; if (f[a[0] - 96]) e = -1;//如果被用过，标记ERR else //反之存起来并标记 f[a[0] - 96] = 1, g[e] = a[0] - 96; cin &gt;&gt; a &gt;&gt; b; if (a[0] != &#x27;n&#x27;&amp;&amp;b[0] == &#x27;n&#x27;&amp;&amp;k == 0) h++, l[e] = 1;//如果a是数字，b是n，而且可以运行，那么当前复杂度+1 else if (((a.length() == b.length() &amp;&amp; a &gt; b) || (a.length() &gt; b.length()) || (a[0] == &#x27;n&#x27;&amp;&amp;b[0] != &#x27;n&#x27;)) &amp;&amp; k == 0) k = 1, n = e; &#125; else//如果是E &#123; m = max(m, h); f[g[e]] = 0; //将最大复杂度更改 ，变量标记没用过 if (l[e] == 1) h--, l[e] = 0; e--; if (n &gt; 0 &amp;&amp; e &lt; n) k = 0, n = 0; //如果当前循环加了复杂度，当前复杂度-1，标记清空 &#125; if (e == -1) printf(&quot;ERR\\n&quot;), c = -1; &#125; //处理结果 if (e &gt; 0) printf(&quot;ERR\\n&quot;); if (e == 0 &amp;&amp; m == d) printf(&quot;Yes\\n&quot;); if (e == 0 &amp;&amp; m != d) printf(&quot;No\\n&quot;); &#125; return 0;&#125; ~","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"模拟","slug":"模拟","permalink":"https://hntr.xyz/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"CSP-S-2019-D1-T2题解","slug":"CSP-S-2019-D1-T2","date":"2020-05-02T14:52:20.000Z","updated":"2020-05-10T08:05:48.000Z","comments":true,"path":"CSP-S-2019-D1-T2.html","link":"","permalink":"https://hntr.xyz/CSP-S-2019-D1-T2.html","excerpt":"题面链接-luogu 题解1.括号序列一定是从父节点传递下来的如果用sum[i]表示当前节点的累计，用tail[i]表示以当前节点为结尾的合法字串匹配数量可以得到$sum[x] = sum[fa[x]] + tail[x]$注：fa[x]是x的父节点","text":"题面链接-luogu 题解1.括号序列一定是从父节点传递下来的如果用sum[i]表示当前节点的累计，用tail[i]表示以当前节点为结尾的合法字串匹配数量可以得到$sum[x] = sum[fa[x]] + tail[x]$注：fa[x]是x的父节点 使用栈储存遍历时的信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long //不开ll见const int maxn = 5e5 + 100;ll n, tot, ans;int head[maxn], pre[maxn], tree[maxn]; //链式前向星int w[maxn], f[maxn]; //w是储存节点括号信息 f是父节点信息ll tail[maxn], sum[maxn]; //tail，sum见上方 bool v[maxn]; //是否已经遍历stack&lt;int&gt; q;void add(int x, int y)&#123; tree[++tot] = y; pre[tot] = head[x]; head[x] = tot;&#125;void dfs(int x)&#123; int tmp = 0; if (q.size() &amp;&amp; w[q.top()] + w[x] == 0 &amp;&amp; w[x] == -1) //判断是否是合法的 &#123; //是合法的就将当前tail值更新 tmp = q.top(); q.pop(); v[tmp] = 0; tail[x] = tail[f[tmp]] + 1; &#125; else q.push(x), v[x] = 1;//否则继续 sum[x] = sum[f[x]] + tail[x];//更新sum for (int i = head[x]; i; i=pre[i])//继续遍历 dfs(tree[i]); //复原栈 if (v[x]) q.pop(), v[x] = 0; if (tmp) q.push(tmp), v[tmp] = 1;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; char tmp; cin &gt;&gt; tmp; if (tmp == &#x27;(&#x27;) w[i] = 1; else w[i] = -1; &#125; for (int i = 2; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;, &amp;f[i]); add(f[i],i); &#125; //上方全是输入 dfs(1); for (int i = 1; i &lt;= n; ++i) ans ^= i * sum[i];//计算答案 cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"https://hntr.xyz/tags/CSP/"},{"name":"NOIP","slug":"NOIP","permalink":"https://hntr.xyz/tags/NOIP/"},{"name":"树","slug":"树","permalink":"https://hntr.xyz/tags/%E6%A0%91/"},{"name":"栈","slug":"栈","permalink":"https://hntr.xyz/tags/%E6%A0%88/"}]},{"title":"CSP-S-2019-D1-T1题解","slug":"CSP-S-2019-D1-T1","date":"2020-05-02T14:52:09.000Z","updated":"2020-05-10T08:05:48.000Z","comments":true,"path":"CSP-S-2019-D1-T1.html","link":"","permalink":"https://hntr.xyz/CSP-S-2019-D1-T1.html","excerpt":"格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间恰好有一位不同，特别地，第一个串与最后一个串也算作相邻。 ……………… 现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的$k$ 号二进制串。","text":"格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间恰好有一位不同，特别地，第一个串与最后一个串也算作相邻。 ……………… 现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的$k$ 号二进制串。 直接找规律 题解提交记录 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define ull unsigned long longusing namespace std;int main()&#123; ull n,k; cin &gt;&gt; n &gt;&gt; k; k^=k &gt;&gt; 1; while(n) &#123; n--; cout &lt;&lt; (k &gt;&gt; n &amp; 1); //硬核找规律 &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"https://hntr.xyz/tags/CSP/"},{"name":"模拟","slug":"模拟","permalink":"https://hntr.xyz/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数学","slug":"数学","permalink":"https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"NOIP","slug":"NOIP","permalink":"https://hntr.xyz/tags/NOIP/"}]},{"title":"P2286[HNOI2004]题解","slug":"P2286[HNOI2004]题解","date":"2020-02-03T14:41:00.000Z","updated":"2020-02-11T09:39:40.000Z","comments":true,"path":"P2286[HNOI2004]题解.html","link":"","permalink":"https://hntr.xyz/P2286[HNOI2004]%E9%A2%98%E8%A7%A3.html","excerpt":"这道题目可以算是一道set的板子题（在CJC大佬的提醒下恍然大悟，CJC的博客），于是这篇题解某种意义上其实是对于set的讲解和复习。关于STL的话，全称为Standard Template Library，说白了就是一个非常多功能的库，引用时按情况引用，可能会有set map algorithm等等，按情况来分析，用途很多，有封装好的快排、大根小根堆（优先队列）、二分查找、全排列、各种神仙玩意儿。set则是其中的一个工具。","text":"这道题目可以算是一道set的板子题（在CJC大佬的提醒下恍然大悟，CJC的博客），于是这篇题解某种意义上其实是对于set的讲解和复习。关于STL的话，全称为Standard Template Library，说白了就是一个非常多功能的库，引用时按情况引用，可能会有set map algorithm等等，按情况来分析，用途很多，有封装好的快排、大根小根堆（优先队列）、二分查找、全排列、各种神仙玩意儿。set则是其中的一个工具。 Setset和multiset的区别是，后者可以有重复的元素，前者不可以。set插入重复元素可能会不成功，所以有重复元素要用multiset。用法： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt; //set所在的库using namespace std;int main()&#123; set&lt;int&gt; st; //定义方法，其他类型类似 int a[10] = &#123;1, 2, 3, 8, 7, 7, 5, 6, 8, 12&#125;; for (int i = 1; i &lt; 10; ++i) st.insert(a[i]);//插入方式 cout &lt;&lt; st.size() &lt;&lt; endl; //st.size()返回这个set的大小，整形 set&lt;int&gt;::iterator i; //迭代器，类似于一个指向set中某个元素的指针，不可以比较大小，不可以相加相减，但可以++i（迭代） for (i = st.begin(); i != st.snd(); ++i) //由于迭代器的特殊性，只能用这种方式进行循环 cout &lt;&lt; * i &lt;&lt; &quot;,&quot;; cout endl; pair&lt;set&lt;int&gt;::iterator, bool&gt; result = st.insert(2); if (!result.second) cout &lt;&lt; * result.first &lt;&lt; &quot; already exists.&quot; &lt;&lt; endl; else cout &lt;&lt; * result.first &lt;&lt; &quot; inserted.&quot; &lt;&lt; endl; return 0;&#125; 更多的关于set的用法和函数详解，可以访问C++ reference 这道题目题目简述：凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。 每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值$a$（$a$是一个正整数，$a&lt;2^{31}$），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。 被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为$a$，那么它将会领养一只目前未被领养的宠物中特点值最接近$a$的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为$a-b$和$a+b$，那么领养者将会领养特点值为$a-b$的那只宠物。 收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为$a$，存在两个领养者他们希望领养宠物的特点值分别为$a-b$和$a+b$，那么特点值为$a-b$的那个领养者将成功领养该宠物。 一个领养者领养了一个特点值为$a$的宠物，而它本身希望领养的宠物的特点值为$b$，那么这个领养者的不满意程度为$abs(a-b)$。 你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。 问题解决： 知道了set怎么用，辣么就好办了（好像还要知道一个lower_bound()） 我们只要把每次宠物的编号插入，然后直接查询，查询的话也是用STL中的lower_bound和uper_bound，然后这道题目就可以A了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt; //万能头文件using namespace std;const int MAXN = 1000010;const int MAX_INT = 1e9;int n, ans;set&lt;int&gt; s; //定义setvoid find(int x) &#123; set&lt;int&gt;::iterator left, right;//定义迭代器 left = --s.lower_bound(x); right = s.lower_bound(x); if (x - *left &lt;= *right - x &amp;&amp; *left != -MAX_INT) &#123; ans += x - *left; s.erase(left); &#125; else &#123; ans += *right - x; s.erase(right); &#125; ans %= 1000000;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); int hod; s.insert(-MAX_INT), s.insert(MAX_INT); //通过插入最大整型和最小整型来防止查找溢出，这是一位大佬的方法，非常秒！！ for (int i = 1; i &lt;= n; i++) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (s.size() == 2) &#123; hod = a; s.insert(b); &#125; else if (a == hod) s.insert(b); else find(b); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 完事儿~考虑在写一个关于STL的整合，这一切都要从一只🦇说起……","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"STL","slug":"STL","permalink":"https://hntr.xyz/tags/STL/"},{"name":"set","slug":"set","permalink":"https://hntr.xyz/tags/set/"}]},{"title":"LCA最近公共祖先","slug":"LCA最近公共祖先","date":"2020-01-21T16:00:00.000Z","updated":"2020-02-16T12:15:26.000Z","comments":true,"path":"LCA最近公共祖先.html","link":"","permalink":"https://hntr.xyz/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html","excerpt":"学习了 LCA（最近公共祖先） 这个高级的东西。。于是乎来发一些理解和题解以便以后复习。 什么是LCALCA就是LCA就是求一棵树上两个节点最近的公共祖先，那么有什么用呢，用来做题。 LCA的实现这里用到了“爬树”的方法找例如两个节点$x,y$:规定$deepth_x&gt;deepth_y$1.让深的那个节点,$x$往树上爬，直到$deepth_x = deepth_y$；2.让两个节点一起向上跳，如果碰在一起了，那么就找到了。嗯，真是生动形象好理解呢！","text":"学习了 LCA（最近公共祖先） 这个高级的东西。。于是乎来发一些理解和题解以便以后复习。 什么是LCALCA就是LCA就是求一棵树上两个节点最近的公共祖先，那么有什么用呢，用来做题。 LCA的实现这里用到了“爬树”的方法找例如两个节点$x,y$:规定$deepth_x&gt;deepth_y$1.让深的那个节点,$x$往树上爬，直到$deepth_x = deepth_y$；2.让两个节点一起向上跳，如果碰在一起了，那么就找到了。嗯，真是生动形象好理解呢！ 代码实现存储方式一种神奇的存树、图的方式：edge[cnt]数组存储了第cnt条边，其中to表示这条边指向的节点;pre则是指同一个点出发，比当前点早一个添加的边的编号，别的大佬好像是用nxt。head[x]存储了从x出发的所有边中最近添加的边感受一下，会懂的😉 12345int head[MAXN];struct Node&#123; int to, pre;&#125;edge[(MAXN) * 2]; 增加边有了之上的存储方式，那么就有了下面的加边方法（cnt初始为0） 1234567void addedge(int x, int y)&#123; //edge[++cnt].to = y; //edge[cnt].pre = head[x]; edge[++cnt] = (Node)&#123;head[x], y&#125;;//这句和上面两句一样，但它压行了 head[x] = cnt;&#125; 初始化深搜初始化deepth数组（每个节点在树中的深度）；利用倍增思想，类似st表的方式，预处理father数组：$father[x][i]$表示$x$节点向上爬$2^i$后的位置更新方程式：$father[now][i] = father[father[now][i - 1]][i - 1];$解释：现在向上爬$2^i$的位置等于向上爬$2^{i-1}$再向上爬$2^{i-1}$ 123456789101112void build(int now, int fa)&#123; father[now][0] = fa; deepth[now] = deepth[fa] + 1; for (int i = 1; (1 &lt;&lt; i) &lt;= deepth[now]; ++i) father[now][i] = father[father[now][i - 1]][i - 1]; for (int i = head[now]; i; i = edge[i].pre) if (edge[i].to != fa)//遍历下一条边，只要不是指向他父亲的就继续 build(edge[i].to, now);&#125; 查询lca的关键部分,看代码挺好理解的 12345678910111213141516171819int lca(int x, int y)&#123; if (depth[x] &lt; depth[y])//方便起见，规定x总比y深，不然换一下 swap(x, y); for (int i = 29; i &gt;= 0; --i)//让x向上爬，但不能比y浅，这里可以直接像我这样暴力30次，没有关系 if (depth[father[x][i]] &gt;= depth[y]) x = father[x][i]; if (x == y) return x;//特判 for (int i = 29; i &gt;= 0; --i)//xy一起向上跳 if (father[x][i] != father[y][i]) &#123; x = father[x][i]; y = father[y][i]; &#125; return father[x][0];//最后返回x节点上一层的节点，即为最近公共祖先&#125; 总的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define MAXN 500000 + 9using namespace std;int cnt = 0, n, m, s;int father[MAXN][30], head[MAXN], depth[MAXN];struct Node&#123; int to, pre;&#125;edge[(MAXN) * 2];void addedge(int x, int y)&#123; edge[++cnt].to = y; edge[cnt].pre = head[x]; head[x] = cnt;&#125;void dfs(int now, int fa)&#123; father[now][0] = fa; depth[now] = depth[fa] + 1; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[now]; ++i) father[now][i] = father[father[now][i - 1]][i - 1]; for (int i = head[now]; i; i = edge[i].pre) if (edge[i].to != fa) dfs(edge[i].to, now);&#125;int lca(int x, int y)&#123; if (depth[x] &lt; depth[y]) swap(x, y); for (int i = 29; i &gt;= 0; --i) if (depth[father[x][i]] &gt;= depth[y]) x = father[x][i]; if (x == y) return x; for (int i = 29; i &gt;= 0; --i) if (father[x][i] != father[y][i]) &#123; x = father[x][i]; y = father[y][i]; &#125; return father[x][0];&#125;int main()&#123; int a, b; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= n - 1; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); addedge(a, b); addedge(b, a); &#125; dfs(s, 0); for (int i = 1; i &lt;= m; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\\n&quot;, lca(a, b)); &#125; return 0;&#125; 完事儿peace~","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"LCA","slug":"LCA","permalink":"https://hntr.xyz/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"}]},{"title":"ST表","slug":"ST表","date":"2020-01-20T16:00:00.000Z","updated":"2020-02-02T15:26:02.000Z","comments":true,"path":"ST表.html","link":"","permalink":"https://hntr.xyz/ST%E8%A1%A8.html","excerpt":"学习了 ST表 这个高级的东西。。于是乎来发一些理解和题解以便以后复习。 什么是ST表ST表的功能很简单：它是解决RMQ问题(区间最值问题)的一种强有力的工具。它可以做到$O(nlogn)$预处理，$O(1)$查询最值（ohhhhhhhh）","text":"学习了 ST表 这个高级的东西。。于是乎来发一些理解和题解以便以后复习。 什么是ST表ST表的功能很简单：它是解决RMQ问题(区间最值问题)的一种强有力的工具。它可以做到$O(nlogn)$预处理，$O(1)$查询最值（ohhhhhhhh） 实现怎么做到的呢，它运用了倍增的思想。 拿最大值来说我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值(也就是说当前位置是被包含进$2^j$个数去的) 那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值（注意这里的编号是从$1$开始的） 查询的时候也比较简单我们计算出$log_2{lenth}$,然后对于左端点和右端点分别进行查询，这样可以保证一定可以覆盖查询的区间 所以就有了这两个边界，$[l,l+2^k-1]$, $[r-2^k+1,r]$至于为什么会是$[r-2^k+1,r]$，你只要设左端点为$x$, 并且$x$满足$x + 2^k - 1 = r$, 然后就可以推出来了。 例题和代码给定一个长度为 $N$ 的数列，和 $M$ 次询问，求出每一次询问的区间内数字的最大值。 上代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define MaxN 100000 + 9#define LogN 17 //顶多2的17次方就可以从左端到最右端了using namespace std;int f[MaxN][LogN], n, m;inline int read() //快读 很容易暴毙&#123; char c=getchar();int x=0,f=1; while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)f=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;// x + (1 &lt;&lt; len) - 1=r 草稿请无视🤣int ask(int l, int r)&#123; int len = log2(r - l + 1); return max(f[l][len], f[r - (1 &lt;&lt; len) + 1][len]); //关键，这样可以保证覆盖需要查询的区间&#125;int main()&#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) f[i][0] = read();//预处理的时候存在0的位置 for (int j = 1; j &lt;= 21; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); //转移方程式 int a, b; for (int i = 1; i &lt;= m; ++i) &#123; a = read(); b = read(); printf(&quot;%d\\n&quot;, ask(a, b)); &#125; return 0;&#125; 嗯，没有四倍经验。peace~","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"倍增","slug":"倍增","permalink":"https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"},{"name":"ST表","slug":"ST表","permalink":"https://hntr.xyz/tags/ST%E8%A1%A8/"}]},{"title":"线段树","slug":"线段树","date":"2020-01-19T16:00:00.000Z","updated":"2020-02-01T13:19:04.000Z","comments":true,"path":"线段树.html","link":"","permalink":"https://hntr.xyz/%E7%BA%BF%E6%AE%B5%E6%A0%91.html","excerpt":"这两节课学习了 线段树 这个高级的东西。。于是乎来发一些理解和题解以便以后复习。 什么是线段树先来康康这类问题：长度为$n$的数列${a_1, a_2, … , a_n}$（1）求最值：给定$i$,$j&lt;=n$，求${a_i, …, a_j}$区间内的最值。（2）修改元素：给定$k$和$x$，把$a_k$改成$x$。显然你可以用暴力去做，但是","text":"这两节课学习了 线段树 这个高级的东西。。于是乎来发一些理解和题解以便以后复习。 什么是线段树先来康康这类问题：长度为$n$的数列${a_1, a_2, … , a_n}$（1）求最值：给定$i$,$j&lt;=n$，求${a_i, …, a_j}$区间内的最值。（2）修改元素：给定$k$和$x$，把$a_k$改成$x$。显然你可以用暴力去做，但是 如果在加一些操作，比如（3）给定$n$个元素${a_1, a_2, … , a_n} $：• 加：给定$i, j&lt;=n$，把${a_i, …, a_j}$区间内的每个元素加$v$。• 查询：给定$L, R&lt;=n$，计算${a_L, …, a_R}$的区间和。 那么暴力就暴毙。。。 于是就讲了线段树。大概长这个样子：他的每个节点都含有l和r代表了它这个节点所代表的线段或者说是区间， 所以一颗线段树就可以把一根线（一个区间）分成线段（子区间），就比如上面这颗。对于解决区间最值的问题，每个节点多出一个num去存储当前区间的最值即可。然后我们来看操作。 线段树的基本操作首先我们来看个例题，Luogu P3374 例题1题面题目描述如题，已知一个数列，你需要进行下面两种操作： 将某一个数加上 $x$ 求出某区间每一个数的和 输入格式第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下： 1 x k 含义：将第 $x$ 个数加上 $k$ 2 x y 含义：输出区间 $[x,y]$内每个数的和 输出格式输出包含若干行整数，即为所有操作 $2$ 的结果。 这是luogu的线段树模板题1，涉及的操作有建树、修改单点、查询区间和 例题2题面题目描述如题，已知一个数列，你需要进行下面两种操作： 1.将某区间每一个数加上x 2.求出某区间每一个数的和 涉及的操作还有 区间修改 操作建树首先线段树是存在数组里的，数组每一个都是一个结构体注意因为是数组存树，所以要开4被MAXN 12345struct Node&#123; int l, r; //表示区间左右端点 int sum; //在本题中sum表示此区间内所有的和&#125;tree[4 * MaxN]; 然后就是建树 123456789101112int build(int index, int l, int r) // index指的是当前节点在tree数组中的位置&#123; tree[index].l = l; tree[index].r = r; if (l == r) //如果左右端点一样说明他是一个点，更新sum为输入的值 &#123; tree[index].sum = input[l]; // input是输入的数组 return input[l]; &#125; tree[index].sum = build(lson, l, (l + r) &gt;&gt; 1) + build(rson, ((l + r) &gt;&gt; 1) + 1, r); //递归继续建树 return tree[index].sum;&#125; 单点修改其实后来发现没啥用， 因为可以用区间修改的函数，l=r 123456789101112void add(int index, int x, int k)&#123; tree[index].sum += k;//只要是遍历到的节点都要加K if (tree[index].l == tree[index].r) return; if (x &lt;= tree[index &lt;&lt; 1].r) //遍历左子树 add(index &lt;&lt; 1, x, k); if (x &gt;= tree[(index &lt;&lt; 1) + 1].l) //遍历右子树 index &lt;&lt; 1 等价于 index * 2 但是位运算更快 add((index &lt;&lt; 1) + 1, x, k);&#125; 区间查询（无懒标记）区间查询就是，每查到一个区间，有三种选择： 1、如果这个区间被完全包括在目标区间内，那么加上这个区间的和，然后return； 2、如果这个区间的right&gt;目标区间的left，那么查询这个区间； 3、如果这个区间的left&lt;目标区间的right，也查询这个区间; 12345678910111213void searchlr(int index, int left, int right)&#123; if (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right) //此节点被要查询的区间包含 &#123; ans += tree[index].sum; return; &#125; if (tree[index &lt;&lt; 1].r &gt;= left) //要查询的区间有部分在左子树 searchlr(index &lt;&lt; 1, left, right); if (tree[(index &lt;&lt; 1) + 1].l &lt;= right) //要查询的区间有部分在右子树 searchlr((index &lt;&lt; 1) + 1, left, right);&#125; 例题1代码综上即可，总的就不放了，因为太乱了 区间修改然后便是例题2，这一题不同于前一题，因为涉及了区间修改，那么就要涉及另一个东西：LazyTag LazyTag我感觉跟图片懒加载有点像，就是不涉及真正使用是不需要深入加载 首先，懒标记的作用是记录每次、每个节点要更新的值,优点在于传递式记录而不是全记录（全记录还是很慢） 当执行区间修改操作时：若整个区间都被操作时，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果只修改了自己的话，那就只改变自己。 之后，如果我们采用上述的优化方式的话，我们就需要在每次区间的查询修改时pushdown一次，以免重复或者冲突或者爆炸qwq 至于pushdown，就是将节点的lazytag信息向下传递 1234567891011121314151617181920212223242526272829void pushdown(int index)&#123; if (tree[index].tag) //如果有信息 &#123; tree[index &lt;&lt; 1].sum += tree[index].tag * (tree[index &lt;&lt; 1].r - tree[index &lt;&lt; 1].l + 1); //把左子树的sum加上 tree[(index &lt;&lt; 1) + 1].sum += tree[index].tag * (tree[(index &lt;&lt; 1) + 1].r - tree[(index &lt;&lt; 1) + 1].l + 1); //把右子树的sum加上 tree[index &lt;&lt; 1].tag += tree[index].tag; //将懒标记信息传递 tree[(index &lt;&lt; 1) + 1].tag += tree[index].tag; tree[index].tag = 0; //清零本节点标记^.^ &#125;&#125;void addlr(int index, int left, int right, int k)&#123; if (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right) &#123; tree[index].sum += (long long) k * (tree[index].r - tree[index].l + 1); tree[index].tag += k; // lazy tag return; &#125; //如果区间修改的区间没有包含本区间，那就要更新一次懒标记，不然下一层算的时候会出锅 pushdown(index); if (tree[index &lt;&lt; 1].r &gt;= left) addlr(index &lt;&lt; 1, left, right, k); if (tree[(index &lt;&lt; 1) + 1].l &lt;= right) addlr((index &lt;&lt; 1) + 1, left, right, k); tree[index].sum = tree[index &lt;&lt; 1].sum + tree[(index &lt;&lt; 1) + 1].sum; //最后回来累计上&#125; 区间查询（有懒标记）还是分块思想，每查到一个区间，有三种选择： 1、如果这个区间被完全包括在目标区间内，那么加上这个区间的和，然后return； pushdown（很重要） 2、如果这个区间的right&gt;目标区间的left，那么查询这个区间； 3、如果这个区间的left&lt;目标区间的right，也查询这个区间; 123456789101112131415void searchlr(int index, int left, int right)&#123; if (tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right) &#123; ans += tree[index].sum; return; &#125; spread(index);//不要忘记传递信息 if (tree[index &lt;&lt; 1].r &gt;= left) searchlr(index &lt;&lt; 1, left, right); if (tree[(index &lt;&lt; 1) + 1].l &lt;= right) searchlr((index &lt;&lt; 1) + 1, left, right);&#125; 然后就完事了！！！ 那我们来做到题目吧不，我不想做题目四倍经验，一次满足😲哦？？ 线段树的小题目Luogu P2574 题目描述AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下 拥有一个伤害串，是一个长度为 $n$ 的只含字符 0 和字符 1 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。 给定一个范围 $[l, r]$，伤害为伤害串的这个范围内中字符 1 的个数 会修改伤害串中的数值，修改的方法是把 $[l, r]$ 中所有原来的字符 0 变成 1，将 1 变成 0。 AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。 题解！首先这是一道线段树的题，那么线段树的节点都记录了什么呢？首先是左右端点（废话，但是cjc巨佬告诉我可以不用l，r），然后是sum代表该区间1的数量，tag懒标记其实就是此区间变不变，因为翻来翻去就回来了因为是01变化，所以反转后1的个数就等于区间长度-原本1的个数其他的操作和线段树差不多，要注意的是pushdown的思路（有点小坑）： 1234567891011void pushdown(int index)&#123; if (tree[index].tag) &#123; tree[lson].sum = (tree[lson].r - tree[lson].l + 1) - tree[lson].sum; //更新左子树，左子树翻转 tree[rson].sum = (tree[rson].r - tree[rson].l + 1) - tree[rson].sum; //右 tree[lson].tag ^= 1; //更新左右子树信息，0变1，1变0 tree[rson].tag ^= 1; tree[index].tag = 0; &#125;&#125; 总体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define MaxN 200000 + 9#define lson index &lt;&lt; 1#define rson index &lt;&lt; 1 | 1using namespace std;struct Node&#123; int l, r; int sum; bool tag = 0;&#125;tree[4 * MaxN];//不要忘记开4倍int n, m, input[MaxN], ans = 0;int build(int index, int l, int r)&#123; tree[index].l = l; tree[index].r = r; if (l == r) &#123; tree[index].sum = input[l]; return input[l]; &#125; tree[index].sum = build(lson, l, (l + r) &gt;&gt; 1) + build(rson, ((l + r) &gt;&gt; 1) + 1, r); return tree[index].sum;&#125;void pushdown(int index)&#123; if (tree[index].tag) &#123; tree[lson].sum = (tree[lson].r - tree[lson].l + 1) - tree[lson].sum; tree[rson].sum = (tree[rson].r - tree[rson].l + 1) - tree[rson].sum; tree[lson].tag ^= 1; tree[rson].tag ^= 1; tree[index].tag = 0; &#125;&#125;void add(int index, int l, int r)&#123; if (tree[index].l &gt;= l &amp;&amp; tree[index].r &lt;= r) &#123; tree[index].sum = (tree[index].r - tree[index].l + 1) - tree[index].sum; tree[index].tag ^= 1; return; &#125; pushdown(index); if (tree[lson].r &gt;= l) add(lson, l, r); if (tree[rson].l &lt;= r) add(rson, l, r); tree[index].sum = tree[lson].sum + tree[rson].sum; return;&#125;void ask(int index, int l, int r)&#123; if (tree[index].l &gt;= l &amp;&amp; tree[index].r &lt;= r) &#123; ans += tree[index].sum; return; &#125; pushdown(index); if (tree[lson].r &gt;= l) ask(lson, l, r); if (tree[rson].l &lt;= r) ask(rson, l, r);&#125;int main()&#123; char ch[MaxN]; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%s&quot;, &amp;ch); for (int i = 0; i &lt; n; ++i) &#123; input[i + 1] = ch[i] ^ 48; &#125; //输入 build(1, 1, n);//建树 for (int i = 1; i &lt;= m; ++i) &#123; int a, b, c; scanf(&quot;%d&quot;, &amp;a); if (a == 0)//变换 &#123; scanf(&quot;%d%d&quot;, &amp;b, &amp;c); add(1, b, c); &#125; if (a == 1)//查询、输出 &#123; ans = 0; scanf(&quot;%d%d&quot;, &amp;b, &amp;c); ask(1, b, c); printf(&quot;%d\\n&quot;, ans); &#125; &#125; return 0;&#125; 四倍经验！！！做出这一题，剩下的这几题思路一摸一样，只用注意一下各个题目的初始条件和查询方式即可然后就可以收获好多AC啦！！！ 总结发现线段树理清了思路还是挺好打的一个数据结构，但是要注意的事情还是挺多的，毕竟比较长：1.tree数组要开4倍2.建议用宏定义进行一波lson rson什么的定义，不然可能会打到崩溃3.暂时好像没啥了 总之，你看这个代码它又长又宽，就像这个鼠标它又大又圆（大雾） 希望大家都可以熟练运用线段树！","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"线段树","slug":"线段树","permalink":"https://hntr.xyz/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"P1441题解","slug":"P1441题解","date":"2019-10-11T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"P1441题解.html","link":"","permalink":"https://hntr.xyz/P1441%E9%A2%98%E8%A7%A3.html","excerpt":"题目链接 题目描述现有n个砝码，重量分别为a1，a2，a3，……，an，在去掉m个砝码后，问最多能称量出多少不同的重量（不包括0）。 请注意，砝码只能放在其中一边。","text":"题目链接 题目描述现有n个砝码，重量分别为a1，a2，a3，……，an，在去掉m个砝码后，问最多能称量出多少不同的重量（不包括0）。 请注意，砝码只能放在其中一边。 ## 输入格式输入文件weight.in的第1行为有两个整数n和m，用空格分隔 第2行有n个正整数a1，a2，a3，……，an，表示每个砝码的重量。 输出格式输出文件weight.out仅包括1个整数，为最多能称量出的重量数量。 输入输出样例输入3 11 2 2 输出3 说明/提示【样例说明】在去掉一个重量为2的砝码后，能称量出1，2，3共3种重量。 【数据规模】对于20%的数据，m=0； 对于50%的数据，m≤1； 对于50%的数据，n≤10； 对于100%的数据，n≤20，m≤4，m＜n，ai≤100。 题解首先枚举取哪几个，然后DP找这种的取法的最多可称量数，与ans比较即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int ans=0, n, m, a[25], arr[25];bool took[25],dp[100*100+20];void check()&#123; memset(arr, 0, sizeof(arr)); memset(dp, 0, sizeof(dp)); int cnt=0,sum=0; dp[0]=1; for (int i=1; i&lt;=n; i++) if (!took[i]) &#123; arr[++cnt]=a[i]; sum += a[i]; &#125; //cout &lt;&lt; sum; for (int i=1; i&lt;=cnt; i++) for (int j=sum; j&gt;=arr[i]; j--) &#123; dp[j]|=dp[j-arr[i]]; &#125; int tmp=0; for (int i=1; i&lt;=sum; i++) tmp+=dp[i]; ans=max(ans,tmp);&#125;void dfs(int cnt, int index)&#123; if (cnt == 0) &#123; check(); return; &#125; for (int i=index; i&lt;=n; i++) &#123; took[i]=1; dfs(cnt-1, i+1); took[i]=0; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i=1; i&lt;=n; i++) cin &gt;&gt; a[i]; dfs(m, 1); cout &lt;&lt; ans; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"搜索","slug":"搜索","permalink":"https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","permalink":"https://hntr.xyz/tags/BFS/"}]},{"title":"POJ-2349题解","slug":"POJ-2349题解","date":"2019-08-20T13:04:59.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"POJ-2349题解.html","link":"","permalink":"https://hntr.xyz/POJ-2349%E9%A2%98%E8%A7%A3.html","excerpt":"POJ-2349 题目描述The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network. Two different communication technologies are to be used in establishing the network: every outpost will have a radio transceiver and some outposts will in addition have a satellite channel.","text":"POJ-2349 题目描述The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network. Two different communication technologies are to be used in establishing the network: every outpost will have a radio transceiver and some outposts will in addition have a satellite channel. Any two outposts with a satellite channel can communicate via the satellite, regardless of their location. Otherwise, two outposts can communicate by radio only if the distance between them does not exceed D, which depends of the power of the transceivers. Higher power yields higher D but costs more. Due to purchasing and maintenance considerations, the transceivers at the outposts must be identical; that is, the value of D is the same for every pair of outposts. Your job is to determine the minimum D required for the transceivers. There must be at least one communication path (direct or indirect) between every pair of outposts. InputThe first line of input contains N, the number of test cases. The first line of each test case contains 1 &lt;= S &lt;= 100, the number of satellite channels, and S &lt; P &lt;= 500, the number of outposts. P lines follow, giving the (x,y) coordinates of each outpost in km (coordinates are integers between 0 and 10,000). OutputFor each case, output should consist of a single line giving the minimum D required to connect the network. Output should be specified to 2 decimal points. Sample Input12345612 40 1000 3000 600150 750 Sample Output1212.13 看不懂题目的话就翻译吧 解题思路使用prim构造最小生成树prim是什么 具体请google或者百度搜一搜 但是经历了模拟考用prim构建最小生成树的悲惨过程建议去还是学一下Kruskal算法 推荐博客地址这篇文章 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXINT 0x3f3f3f3fstruct Node&#123; int x,y;&#125;l[600];int m,n;double dis[600],d[605][605];bool book[600];void print()&#123; for (int i=1;i&lt;=n;i++) dis[i]=d[1][i]; book[1]=1; for (int i=1;i&lt;=n-1;i++) &#123; int k=0,mm=MAXINT; for (int j=1;j&lt;=n;j++) if (dis[j]&lt;mm &amp;&amp; book[j]==0) &#123; mm=dis[j]; k=j; &#125; book[k]=1; for (int j=1;j&lt;=n;j++) if (dis[j]&gt;d[j][k] &amp;&amp; book[j]==0) dis[j]=d[j][k]; &#125; sort(dis+1,dis+n+1); //for (int i=1;i&lt;=n;i++) // cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;; printf(&quot;%.2f\\n&quot;,dis[n-m+1]);&#125;int main()&#123; int x; cin&gt;&gt;x; while (x&gt;0) &#123; memset(book,0,sizeof(book)); cin&gt;&gt;m&gt;&gt;n; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;l[i].x&gt;&gt;l[i].y; &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) &#123; if (i==j) d[i][j]=0; else d[i][j]=sqrt((l[i].x-l[j].x)*(l[i].x-l[j].x)+(l[i].y-l[j].y)*(l[i].y-l[j].y)); &#125; /* for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=n;j++) cout&lt;&lt;d[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; */ print(); x--; &#125; return 0;&#125; 这个用的还是prim 因为打起来跟djikstra很像 而去对于这题比较方便","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"POJ","slug":"POJ","permalink":"https://hntr.xyz/tags/POJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://hntr.xyz/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"Prim","slug":"Prim","permalink":"https://hntr.xyz/tags/Prim/"}]},{"title":"HDU-1312题解","slug":"HDU-1312题解","date":"2019-08-20T12:53:18.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"HDU-1312题解.html","link":"","permalink":"https://hntr.xyz/HDU-1312%E9%A2%98%E8%A7%A3.html","excerpt":"题目描述据说翻译是个好东西（这句与题目无关😃） There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.","text":"题目描述据说翻译是个好东西（这句与题目无关😃） There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above. InputThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set) OutputFor each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output12344559613 解题思路一道深搜水题 嗯我就是来水题解的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;char map[22][22];int n, m;int result = 1;int x, y;void dfs(int a, int b) &#123; map[a][b] = &#x27;#&#x27;; result++; if (a - 1 &gt; 0 &amp;&amp; map[a - 1][b] == &#x27;.&#x27;) &#123; dfs(a - 1, b); &#125; if (a + 1 &lt;= n &amp;&amp; map[a + 1][b] == &#x27;.&#x27;) &#123; dfs(a + 1, b); &#125; if (b - 1 &gt; 0 &amp;&amp; map[a][b - 1] == &#x27;.&#x27;) &#123; dfs(a, b - 1); &#125; if (b + 1 &lt;= m &amp;&amp; map[a][b + 1] == &#x27;.&#x27;) &#123; dfs(a, b + 1); &#125;&#125;int main() &#123; while (cin &gt;&gt; m &gt;&gt; n) &#123; if (n == 0 &amp;&amp; m == 0) break; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; char s; cin &gt;&gt; s; if (s == &#x27;@&#x27;) &#123; x = i; y = j; &#125; map[i][j] = s; &#125; &#125; map[x][y] = &#x27;#&#x27;; if (x-1 &gt; 0 &amp;&amp; map[x - 1][y] == &#x27;.&#x27;) &#123; dfs(x - 1, y); &#125; if (x + 1 &lt;= n &amp;&amp; map[x + 1][y] == &#x27;.&#x27;) &#123; dfs(x + 1, y); &#125; if (y - 1 &gt; 0 &amp;&amp; map[x][y - 1] == &#x27;.&#x27;) &#123; dfs(x, y - 1); &#125; if (y + 1 &lt;= m &amp;&amp; map[x][y + 1] == &#x27;.&#x27;) &#123; dfs(x, y + 1); &#125; cout &lt;&lt; result &lt;&lt; endl; result = 1; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://hntr.xyz/tags/HDU/"},{"name":"搜索","slug":"搜索","permalink":"https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://hntr.xyz/tags/DFS/"}]},{"title":"POJ-3784题解","slug":"POJ-3784题解","date":"2019-08-20T12:41:45.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"POJ-3784题解.html","link":"","permalink":"https://hntr.xyz/POJ-3784%E9%A2%98%E8%A7%A3.html","excerpt":"POJ-3784 题目描述For this problem, you will write a program that reads in a sequence of 32-bit signed integers. After each odd-indexed value is read, output the median (middle value) of the elements received so far.","text":"POJ-3784 题目描述For this problem, you will write a program that reads in a sequence of 32-bit signed integers. After each odd-indexed value is read, output the median (middle value) of the elements received so far. ##Input The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow. The first line of each data set contains the data set number, followed by a space, followed by an odd decimal integer M, (1 ≤ M ≤ 9999), giving the total number of signed integers to be processed. The remaining line(s) in the dataset consists of the values, 10 per line, separated by a single space. The last line in the dataset may contain less than 10 values. OutputFor each data set the first line of output contains the data set number, a single space and the number of medians output (which should be one-half the number of input values plus one). The output medians will be on the following lines, 10 per line separated by a single space. The last line may have less than 10 elements, but at least 1 element. There should be no blank lines in the output. Sample Input1234567893 1 9 1 2 3 4 5 6 7 8 9 2 9 9 8 7 6 5 4 3 2 1 3 23 23 41 13 22 -3 24 -31 -11 -8 -7 3 5 103 211 -311 -45 -67 -73 -81 -99 -33 24 56 Sample Output12345671 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3 -7 -3 如果你题目看不懂的话，快试一试翻译 解题思路我们使用维护两个堆 一个大根堆一个小根堆的方法来进行动态中位数查找当然我推荐直接使用STL的priority_queue，因为不容易写错^ ^具体的维护过程如下： 我们现在读入了一个新的数$x$ 1、如果他比大根堆的堆顶要小，也就是说明他比当前中位数要小，那么把$x$插入大根堆 2、如果他比大根堆的堆顶要大，也就是说明他比当前中位数要打，那么把$x$插入小根堆 3、在维护的过程中如果发现大根堆比小根堆少，弹出小根堆的堆顶插入大根堆直至符合要求 4、在维护的过程中如果发现大根堆的$size-$小根堆的$size&gt;1$ ，弹出大根堆的堆顶假如小根堆直至符合要求 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;priority_queue &lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt; q1;//这个是小根堆 分不清的时候可以跑个程序试一试priority_queue &lt;int&gt; q2;vector &lt;int &gt; a;void Add(int x)&#123; if (q1.empty()) &#123; q1.push(x); return; &#125; if (x&gt;q1.top()) q1.push(x); else q2.push(x); while (q2.size() &gt; q1.size()) &#123; q1.push(q2.top()); q2.pop(); &#125; while (q1.size() &gt; q2.size() + 1) &#123; q2.push(q1.top()); q1.pop(); &#125;&#125;int main()&#123; int t,k; cin&gt;&gt;t; while (t--) &#123; while (q1.size()) q1.pop(); while (q2.size()) q2.pop(); a.clear(); int m,n; cin&gt;&gt;m&gt;&gt;n; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;k; Add(k); if (i%2!=0) a.push_back(q1.top()); &#125; cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;(n+1)/2&lt;&lt;endl; for (int i=0;i&lt;a.size();i++) &#123; if(i &gt; 0 &amp;&amp; i % 10 == 0) putchar(&#x27;\\n&#x27;); if(i % 10) putchar(&#x27; &#x27;); printf(&quot;%d&quot;, a[i]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"POJ","slug":"POJ","permalink":"https://hntr.xyz/tags/POJ/"},{"name":"堆","slug":"堆","permalink":"https://hntr.xyz/tags/%E5%A0%86/"}]},{"title":"POJ-3278题解","slug":"POJ-3278题解","date":"2019-08-20T12:31:18.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"POJ-3278题解.html","link":"","permalink":"https://hntr.xyz/POJ-3278%E9%A2%98%E8%A7%A3.html","excerpt":"POJ-3278 题目描述Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.","text":"POJ-3278 题目描述Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minuteTeleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? 看不懂吗翻译 大意如下农夫想要抓住一头牛 他站在一个地方 牛在一个地方，农夫可以消耗一点体力从当前坐标$X$走到$X+1$,$X-1$或者$X*2$的地方请问最少多少体力能够抓到牛 InputLine 1: Two space-separated integers: N and K OutputLine 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. Sample Input5 17 Sample Output4 解题思路使用广度优先搜索，将当前的位置X所能到达的地方的坐标放入队列，并将当前的坐标从队列中删除，知道队列为空，典型的BFS 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int ans[100005],n,k;queue &lt;int&gt; q;int bfs()&#123; if (n==k) return 0; while (!q.empty()) q.pop(); q.push(n); while (q.size()) &#123; int tmp=q.front(); //cout&lt;&lt;&quot;tmp=&quot;&lt;&lt;tmp&lt;&lt;endl; q.pop(); if (tmp-1&gt;=0 &amp;&amp; tmp-1&lt;=100000 &amp;&amp; ans[tmp-1]==-1) &#123; if (tmp-1==k) return ans[tmp]+1; q.push(tmp-1); ans[tmp-1]=ans[tmp]+1; &#125; if (tmp+1&gt;=0 &amp;&amp; tmp+1&lt;=100000 &amp;&amp; ans[tmp+1]==-1) &#123; if (tmp+1==k) return ans[tmp]+1; q.push(tmp+1); ans[tmp+1]=ans[tmp]+1; &#125; if (tmp*2&gt;=0 &amp;&amp; tmp*2&lt;=100000 &amp;&amp; ans[tmp*2]==-1) &#123; if (tmp*2==k) return ans[tmp]+1; q.push(tmp*2); ans[tmp*2]=ans[tmp]+1; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; memset(ans,-1,sizeof(ans)); ans[n]=0; cout&lt;&lt;bfs(); //for (int i=1;i&lt;=20;i++) // cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; return 0;&#125; 完事儿~","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","permalink":"https://hntr.xyz/tags/BFS/"},{"name":"POJ","slug":"POJ","permalink":"https://hntr.xyz/tags/POJ/"}]},{"title":"20190806模拟赛题解","slug":"20190806模拟赛题解","date":"2019-08-06T12:45:47.000Z","updated":"2020-02-10T07:59:46.000Z","comments":true,"path":"20190806模拟赛题解.html","link":"","permalink":"https://hntr.xyz/20190806%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3.html","excerpt":"一共是6道题目 主要以贪心 动态规划为重点 目前题解更新完前三道 清汤拉面有一天下课，小泉同学、悠、美沙、润相约在一家学校附近的拉面馆。悠、美沙、润都点了清汤拉面。大家都知道，拉面店可以按自己喜好添加配菜，所以她们在面里加了一些叉烧猪肉。小泉发现，悠、美沙、润的碗里分别有$A,B,C$块叉烧猪肉。爱吃拉面的小泉同学希望她们能够吃到一样多的叉烧猪肉，店家提供了两种加配菜的方法： 在2个人的碗中分别加1块叉烧猪肉 在1个人的碗中添加2块叉烧猪肉 小泉同学想知道，最少需要加多少次配菜，能使朋友的碗中叉烧猪肉数量相同呢？","text":"一共是6道题目 主要以贪心 动态规划为重点 目前题解更新完前三道 清汤拉面有一天下课，小泉同学、悠、美沙、润相约在一家学校附近的拉面馆。悠、美沙、润都点了清汤拉面。大家都知道，拉面店可以按自己喜好添加配菜，所以她们在面里加了一些叉烧猪肉。小泉发现，悠、美沙、润的碗里分别有$A,B,C$块叉烧猪肉。爱吃拉面的小泉同学希望她们能够吃到一样多的叉烧猪肉，店家提供了两种加配菜的方法： 在2个人的碗中分别加1块叉烧猪肉 在1个人的碗中添加2块叉烧猪肉 小泉同学想知道，最少需要加多少次配菜，能使朋友的碗中叉烧猪肉数量相同呢？ 输入输入包含多组数据 第一行包含一个第一行一个整数$T(1 \\le T \\le 10^3)$表示输入组数 每组数据一行三个整数$a,b,c(0 \\le a,b,c \\le 10^9)$，分别表示悠、美沙、润碗中的叉烧猪肉数量 输出每组数据输出一个整数，表示最少的加配菜次数 样例输入3 7 5 1 3 2 2 6 6 6 样例输出4 1 0 数据范围 Subtask # 分值 $T$ 的限制 $a, b, c$的限制 1 $30$ $T \\le 10$ $0 \\le a,b,c \\le 100$ 2 $30$ $T \\le 10^3$ $0 \\le a,b,c \\le 10^6$ 3 $40$ $T \\le 10^3$ $0 \\le a,b,c \\le 10^9$ 解题思路求出最大值*3-较小的两个 即为相差的块数能否被2整除，若不能则表明只给这两个较小的加来加去不能解决问题，否则表明可以 代码如下 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main()&#123; long long sum,Max,n,a,b,c,cha; cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; sum=a+b+c; Max=max(a,b); Max=max(Max,c); cha=(Max*3); cha-=sum; if (cha%2) cout&lt;&lt;cha/2+2&lt;&lt;endl; else cout&lt;&lt;cha/2&lt;&lt;endl; &#125; return 0;&#125; 小泉的数组题目描述小泉有一个长度为$n$的$01$串。对于这个串中的每一段连续子串，小泉有两种操作： 把一个子串左右颠倒，如：$011\\to 110$ 把一个子串的$01$互换，如：$000\\to 111$ 对于这两种操作，每做第一种操作的代价为$x$，每做后一种操作的代价为$y$ 现在小泉想把一个串转换为全部为$1$，请问她所需要花费的最小代价为多少？ 输入输出格式输入格式第一行三个整数$n, x, y$，$n$表示$01$串的长度，$x$表示第一种操作的代价，$y$表示后一种操作的代价。 第二行为一个长度为$n$的$01$串，表示需要转换的串。 保证$1 \\le n \\le 10^6, 1 \\le x, y \\le 10^3$。 输出格式输出一行，包含一个整数，表示将该串转换为全为$1$的最小代价。 输入输出样例输入样例1：5 10 1 10010 输出样例1：2 输入样例2：6 2 3 101011 输出样例2：5 说明 Subtask # 分值 $n$ 的限制 $x, y$的限制 1 $20$ $n \\leq 100$ $x, y \\leq 100$ 2 $20$ $n \\leq 10^4$ $x, y \\le 10^3$ 3 $60$ $n \\leq 10^6$ $x, y \\le 10^3$ 解题思路：首先 我们可以发现如果要执行第一种操作的话，必须只能执行一次第二种操作，因为如果一次一一次二会浪费很多，所以一共只有两种方式1.将所有的0串一次一次的使用后者全部转为12.将所有的0串一次一次的使用第一种操作转为一整串0，然后1比较两种的耗费 选择小的一种即可 代码如下： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;char a[1000005];int main()&#123; int n,x,y,ans=0; int t=0; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y; cin&gt;&gt;a; int len=strlen(a); for (int i=0;i&lt;len;i++) &#123; if (a[i]==&#x27;0&#x27;)&#123; int k=i; while (a[k]==&#x27;0&#x27;)k++; for (int j=i;j&lt;k;j++) &#123; a[j]=&#x27;1&#x27;; &#125; ans+=y; t++; &#125; &#125; cout&lt;&lt;min(x*(t-1)+y,ans); return 0;&#125; 酱油拉面悠为了在家给小泉同学做拉面，准备了$n$个面碗，这些面碗排成一线。她打算在每个面碗中都放入小泉同学爱吃的酱油拉面。 由于拉面碗的正反面画上了一样的图案，粗心的悠将一些面碗弄反了。 为了使小泉能够顺利地吃到酱油拉面，她需要将这些的面碗翻转过来。然而，悠在翻转编号为$i$的面碗时，会使两边的，即编号为$i-1$和$i+1$的面碗也被翻转。 假设面碗的编号为$[1,n]$，当悠翻转最左边（编号为$1$）的面碗时，只有编号为$2$的面碗也被翻转；翻转最右边（编号为$n$）的面碗时，只有编号为$n-1$的面碗收到影响；当只有一个面碗时($n=1$)，翻转动作只会作用于当前面碗。 悠很担心她能不能将所有的面碗翻正。如果能，悠想知道最少需要多少次翻转动作，以节约时间来制作美味的拉面呢？ 输入输入包含多组数据 第一行一个整数$T(1 \\le T \\le 100)$表示输入组数 每组数据第一行一个整数$n(1 \\le n \\le 10^5 )$，表示面碗的数量。数据保证$\\sum n \\le 10^6$ 接下来一行包含$n$个数字，其中第$i$个数字$a_i$为0时，表示面碗是正的；当$a_i$为1时，表示面碗是反的 输出对于每一组数据，如果悠不能将翻转所有的面碗，输出一行Sad Yuu 否则输出悠最少需要翻转的次数 ##样例输入 2 5 0 1 0 1 1 8 0 1 1 0 1 0 1 1 样例输出Sad Yuu 3 Subtask # 分值 $T$ 的限制 $\\sum{n}$ 的限制 1 $15$ $T=2$ $\\sum{n} \\leq 20$ 2 $15$ $T \\leq 10$ $\\sum{n} \\leq 10^3$ 3 $20$ $T \\leq 100$ $\\sum{n} \\leq 10^5$ 4 $50$ $T \\leq 100$ $\\sum{n} \\leq 10^6$ 解题思路：看到1就翻他后一个然后从新的优化过的数组再扫一遍输出更少的步数即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;bool a[100005],b[100005];int main()&#123; int t,n; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; if (n==1)//特殊情况考虑 &#123; if (a[1]==1) cout&lt;&lt;1&lt;&lt;endl; if (a[1]==0) cout&lt;&lt;0&lt;&lt;endl; continue; &#125; int ans1=0,ans2=0; for (int i=n;i&gt;=1;i--) b[i]=a[i]; b[1]=!b[1];b[2]=!b[2];ans2++;//优化前两个 以免出现 1 1 式后面判断为Sad Yuu for (int i=1;i&lt;n;i++) &#123; if (a[i])//有一就直接翻他后面一个 &#123; a[i]=!a[i]; a[i+1]=!a[i+1]; a[i+2]=!a[i+2]; ans1++; &#125; &#125; for (int i=1;i&lt;n;i++)//重新做一遍 防止卡1 1 &#123; if (b[i]) &#123; b[i]=!b[i]; b[i+1]=!b[i+1]; b[i+2]=!b[i+2]; ans2++; &#125; &#125; int f1=0,f2=0; for (int i=1;i&lt;=n;i++)//判断是否反转成功 &#123; f1+=a[i]; f2+=b[i]; &#125; //输出 if (f1==0 &amp;&amp; f2==0) cout&lt;&lt;min(ans1,ans2)&lt;&lt;endl; if (f1==0 &amp;&amp; f2!=0) cout&lt;&lt;ans1&lt;&lt;endl; if (f1!=0 &amp;&amp; f2==0) cout&lt;&lt;ans2&lt;&lt;endl; if (f1!=0 &amp;&amp; f2!=0) cout&lt;&lt;&quot;Sad Yuu&quot;&lt;&lt;endl; &#125; return 0;&#125; 四汉诺塔问题背景汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。传说中，大梵天创造世界的时候做了三根金刚石柱子，在一根柱子从下往上按照大小顺序摞着$64$片黄金圆盘，大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 题目描述小泉对于普通的三柱汉诺塔问题已经十分熟悉了，对于$n$个圆盘的汉诺塔问题，最少需要的移动次数为$$f(n) = 2^n -1$$小泉很好奇的是，对于有多个柱子的汉诺塔问题来说，最少的移动次数为多少？ 由于小泉觉得$m$柱汉诺塔问题，当$m \\geq 5$时对你来说太难了，所以你只需要回答当$m=4$时，将$n$个圆盘从第一根柱子移动到另一根柱子的最少移动次数。 因为这个数可能会比较大，所以小泉只需要你输出对$1000000007(10^9+7)$取模的结果即可。 输入输出格式输入格式包含多组输入 第一行一个整数$T$，表示输入组数。 接下来$T$行，一行一个整数$n$，表示圆盘的数量。 保证$1 \\le T \\le 10^3, 1 \\le n \\le 10^3$。 输出格式输出$T$行，每行一个整数，表示将$n$个圆盘移动到另一根柱子的最少移动次数对$1000000007(10^9+7)$取模的结果。 输入输出样例输入样例1：3 2 6 10 输出样例1：3 17 49 说明 Subtask # 分值 $T$ 的限制 $n$的限制 1 $20$ $1$ $n \\leq 10$ 2 $20$ $T \\leq 10$ $n \\leq 50$ 3 $20$ $T \\leq 100$ $n \\le 100$ 4 $20$ $T \\le 10^3$ $n \\le 10^3$ 5 $20$ $T \\le 10^3$ $n \\le 10^6$","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://hntr.xyz/tags/%E5%85%A5%E9%97%A8/"},{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"P1115题解","slug":"P1115题解","date":"2019-08-05T13:47:55.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"P1115题解.html","link":"","permalink":"https://hntr.xyz/P1115%E9%A2%98%E8%A7%A3.html","excerpt":"P1115 题目描述给出一段序列，选出其中连续且非空的一段使得这段和最大。 输入格式第一行是一个正整数$N$，表示了序列的长度。 第二行包含$N$个绝对值不大于$10000$的整数$A_i$，描述了这段序列。","text":"P1115 题目描述给出一段序列，选出其中连续且非空的一段使得这段和最大。 输入格式第一行是一个正整数$N$，表示了序列的长度。 第二行包含$N$个绝对值不大于$10000$的整数$A_i$，描述了这段序列。 输出格式一个整数，为最大的子段和是多少。子段的最小长度为$1$。 解题思路当然你可以暴力枚举$O(n^3)$所以还是动规吧·······$O(n)$ 设数组$dp[i]$存放的一第$i$个数字为结尾的连续字串和最大的值 转移方程式如下： $$dp[i]=max(dp[i-1]+a[i],dp[i])$$ 代码如下： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int n,a[200005],tmp; cin&gt;&gt;n; cin&gt;&gt;tmp; a[1]=tmp; for (int i=2;i&lt;=n;i++) &#123; cin&gt;&gt;tmp; a[i]=max(tmp,a[i-1]+tmp); &#125; int m=-999999999; for (int i=1;i&lt;=n;i++) if (a[i]&gt;m) m=a[i]; cout&lt;&lt;m; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"P1716题解","slug":"P1216","date":"2019-08-05T13:25:08.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"P1216.html","link":"","permalink":"https://hntr.xyz/P1216.html","excerpt":"原题链接 题目描述观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 12345 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的样例中,从7 到 3 到 8 到 7 到 5 的路径产生了最大","text":"原题链接 题目描述观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 12345 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 在上面的样例中,从7 到 3 到 8 到 7 到 5 的路径产生了最大 输入格式第一个行包含 R(1&lt;= R&lt;=1000) ,表示行的数目。 后面每行为这个数字金字塔特定行包含的整数。 所有的被供应的整数是非负的且不大于100。 ##输出格式单独的一行,包含那个可能得到的最大的和。 解题思路非常经典的动态规划 如果只是用简单的递归或者搜索 将会浪费较多的时间因为 比如当你在$2,1$和$2,2$这两个点做选择时，你都将会用到$3,2$的数值，而每次都去求一次数值十分浪费时间，因为求$3,2$的最大值还会不断的重复重复重复…这时，使用记忆化搜索 将每个地方可以得到的最大值存下来将可以省很多的时间当然也可以使用动态规划 转移方程式如下 1dp[i][j]&#x3D;a[i][j]+max(dp[i+1][j],dp[i+1][j+1]) 代码如下 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int a[1003][1003],dp[1003][1003];int main()&#123; int n,x,y; cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; for (int i=n;i&gt;=1;i--)//从上到下和从下到上没有本质区别 for (int j=i;j&gt;=1;j--) dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; cout&lt;&lt;dp[1][1]; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"P1722题解","slug":"P1722题解","date":"2019-08-05T13:14:36.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"P1722题解.html","link":"","permalink":"https://hntr.xyz/P1722%E9%A2%98%E8%A7%A3.html","excerpt":"","text":"题目背景usqwedf 改编系列题。 题目描述如果你在百忙之中抽空看题，请自动跳到第六行。 众所周知，在中国古代算筹中，红为正，黑为负…… 给定一个1*(2n)的矩阵（usqwedf：这不是一个2n的队列么），现让你自由地放入红色算筹和黑色算筹，使矩阵平衡[即对于所有的i(1&lt;=i&lt;=2n)，使第1~i格中红色算筹个数大于等于黑色算筹] 问有多少种方案满足矩阵平衡。 见样例解释。 输入格式正整数 n 输出格式方案数t对100取模 其实就是Catalan数~ 解题思路与这一篇相同 其实可以打表就不用考虑时间复杂度咳咳","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"P1717题解","slug":"P1717题解","date":"2019-08-04T12:43:18.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"P1717题解.html","link":"","permalink":"https://hntr.xyz/P1717%E9%A2%98%E8%A7%A3.html","excerpt":"题目链接 由于题目较长 不做搬运太懒了仅放上题目描述 题目描述话说发源于小朋友精心设计的游戏被电脑组的童鞋们藐杀之后非常不爽，为了表示安慰和鼓励，VIP999 决定请他吃一次“年年大丰收”，为了表示诚意，他还决定亲自去钓鱼。 但是，因为还要准备 NOIP2013, z老师只给了他$H$个小时的空余时间，假设有$n$个鱼塘都在一条水平路边，从左边到右编号为 1, 2, 3 .. n 。","text":"题目链接 由于题目较长 不做搬运太懒了仅放上题目描述 题目描述话说发源于小朋友精心设计的游戏被电脑组的童鞋们藐杀之后非常不爽，为了表示安慰和鼓励，VIP999 决定请他吃一次“年年大丰收”，为了表示诚意，他还决定亲自去钓鱼。 但是，因为还要准备 NOIP2013, z老师只给了他$H$个小时的空余时间，假设有$n$个鱼塘都在一条水平路边，从左边到右编号为 1, 2, 3 .. n 。 VIP是个很讲究效率的孩子，他希望用这些时间钓到尽量多的鱼。他从湖1出发，向右走，有选择的在一些湖边停留一定的时间钓鱼，最后在某一个湖边结束钓鱼。他测出从第$i$个湖到 $i+1$个湖需要走$5 \\times t_i$分钟的路，还测出在第 $i$个湖边停留，第一个5分钟可以钓到鱼%f_i%以后再每钓5分钟鱼，鱼量减少$d_i$。为了简化问题，他假定没有其他人钓鱼，也不会有其他因素影响他钓到期望数量的鱼。请编程求出能钓最多鱼的数量。 解题思路优先队列（有为啥不用）和贪心 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int f,num; bool operator &lt;(node x)const//重载运算符 &#123; return f&lt;x.f; &#125;&#125; a[10001];int n,h,i,j,k,d[10001],t[10001],ans=0;priority_queue&lt;node&gt;q;//优先队列int main()&#123; cin&gt;&gt;n&gt;&gt;h; h*=12;//把题目中的5全部除掉然后再算 for(i=1; i&lt;=n; i++) &#123; cin&gt;&gt;a[i].f; a[i].num=i; &#125; for(i=1; i&lt;=n; i++) cin&gt;&gt;d[i]; for(i=1; i&lt;n; i++) cin&gt;&gt;t[i]; for(i=1; i&lt;=n; i++)//枚举去那些鱼池 &#123; h-=t[i-1];//更新时间 int now=0; while(!q.empty()) q.pop();//清空队列 防止爆炸 for(j=1; j&lt;=i; j++) q.push(a[j]);//入队列构成大根堆 for(j=1; j&lt;=h; j++) &#123; node s; s=q.top();//当前最大 if(s.f&gt;0) now+=s.f; s.f-=d[s.num]; q.pop(); q.push(s);//放回钓完后剩下的鱼的数据 &#125; ans=max(ans,now);//比较更大的收获并更新 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"CF401C题解","slug":"CF401C题解","date":"2019-08-04T12:34:47.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"CF401C题解.html","link":"","permalink":"https://hntr.xyz/CF401C%E9%A2%98%E8%A7%A3.html","excerpt":"题目链接 题意翻译构造一个 01 序列，包含 n 个 0，m 个 1 要求不存在连续 2 个 0，或 3 个 1 1 &lt;= n; m&lt;=1000000","text":"题目链接 题意翻译构造一个 01 序列，包含 n 个 0，m 个 1 要求不存在连续 2 个 0，或 3 个 1 1 &lt;= n; m&lt;=1000000 题目描述Now it’s time of Olympiads. Vanya and Egor decided to make his own team to take part in a programming Olympiad. They’ve been best friends ever since primary school and hopefully, that can somehow help them in teamwork. For each team Olympiad, Vanya takes his play cards with numbers. He takes only the cards containing numbers 1 and 0. The boys are very superstitious. They think that they can do well at the Olympiad if they begin with laying all the cards in a row so that: there wouldn’t be a pair of any side-adjacent cards with zeroes in a row;there wouldn’t be a group of three consecutive cards containing numbers one.Today Vanya brought n n cards with zeroes and m m cards with numbers one. The number of cards was so much that the friends do not know how to put all those cards in the described way. Help them find the required arrangement of the cards or else tell the guys that it is impossible to arrange cards in such a way. 输入格式The first line contains two integers: n n ( 1&lt;=n&lt;=10^{6} 1&lt;=n&lt;=106 ) — the number of cards containing number 0; m m ( 1&lt;=m&lt;=10^{6} 1&lt;=m&lt;=106 ) — the number of cards containing number 1. 输出格式In a single line print the required sequence of zeroes and ones without any spaces. If such sequence is impossible to obtain, print -1. 输入输出样例输入 #1 复制11 2 输出 #11101 输入 #214 8 输出 #21110110110101 输入 #314 10 输出 #3111011011011011 输入 #411 5 输出 #41-1 题解首先 将两种特殊情况即输出-1的判断出来分别是 n &gt; m+1 || m &gt; 2*(n+1)然后根据不同的情况分类输出即可代码如下 仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,m,k,l;void out()&#123; for(int i=1; i&lt;=n; i++) &#123; cout&lt;&lt;&quot;10&quot;; &#125; return ;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; if(n&gt;m+1||m&gt;2*(n+1)) &#123; cout&lt;&lt;&quot;-1&quot;; return 0; &#125; if(n==m) &#123; out(); return 0; &#125; if(n&gt;m) &#123; cout&lt;&lt;&quot;0&quot;; n--; out(); return 0; &#125; k=m/2; while(n&gt;k&amp;&amp;n!=0) &#123; cout&lt;&lt;&quot;1&quot;; m--; cout&lt;&lt;&quot;0&quot;; n--; k=m/2; &#125; l=n; for(int i=1; i&lt;=n; i++) &#123; cout&lt;&lt;&quot;110&quot;; m--; m--; l--; &#125; if(m==1) &#123; cout&lt;&lt;&quot;1&quot;; &#125; else &#123; if(m==2) &#123; cout&lt;&lt;&quot;11&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"190801测试-总结(题目-题解)","slug":"190801测试-总结(题目-题解)","date":"2019-08-02T06:35:13.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"190801测试-总结(题目-题解).html","link":"","permalink":"https://hntr.xyz/190801%E6%B5%8B%E8%AF%95-%E6%80%BB%E7%BB%93(%E9%A2%98%E7%9B%AE-%E9%A2%98%E8%A7%A3).html","excerpt":"20190802的上机测试题目和题解！！ 1.判断素数个数题目描述输入两个整数和，输出两者之间的素数个数（包括$X$和$Y$）","text":"20190802的上机测试题目和题解！！ 1.判断素数个数题目描述输入两个整数和，输出两者之间的素数个数（包括$X$和$Y$） 输入格式两个整数和$X$和$Y$($1&lt;=X,Y&lt;=10^5$) 输出格式输出一个整数，表示$X$，$Y$之间的素数个数（包括$X$和$Y$） 样例样例输入11 100 样例输出125 注意点：有坑😭 $X$不一定大于$Y$ 题解：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;bool p(int x) &#123; bool f = 1; for (int i = 2; i &lt;= sqrt(x); i++) if (x % i == 0) &#123; f = 0; break; &#125; return f;&#125;int main() &#123; // freopen(&quot;prime.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;prime.out&quot;,&quot;w&quot;,stdout); int x, y; cin &gt;&gt; x &gt;&gt; y;//有问题就交换一下 if (x &gt; y) swap(x, y); int ans = 0; for (int i = x; i &lt;= y; i++) if (p(i) &amp;&amp; i != 1) ans++; cout &lt;&lt; ans; return 0;&#125; 2.火车调度序列统计就是Catalan数（虽然知道但是还是没有AC） 题目描述有辆各不相同的火车在车道上等待出站（火车的两端都可以当动力源），火车进站前可以通过一个调度站调整火车出站次序，调度站不限定所能停放的火车数量，每次只能进或出一辆火车。请你编程求出辆火车的不同出站序列的总数。 输入格式一个数$n,(1&lt;=n&lt;=1000)$ 输出格式一个数，即可能输出序列的总数目。 样例样例输入13 样例输出15 题解:公式+高精度 $$C(n) = \\frac{(2n)!}{n!(n+1)!}$$ 以上公式可以化成 $$C(n) = \\frac{(n+2)\\cdot(n+3)\\cdot(n+4)\\cdot\\cdot\\cdot(2n-1)\\cdot(2n)}{n!}$$考的时候没有推出公式 所以就GG了代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int a[100001],h=1;int main()&#123; int n; a[0]=1; cin&gt;&gt;n; for (int i=n+2;i&lt;=n*2;i++)//高精度乘单精度 &#123; for (int j=0;j&lt;h;j++) a[j]*=i; for (int j=0;j&lt;100001;j++)//进位处理 if (a[j]/10&gt;0) &#123; a[j+1]+=a[j]/10; a[j]=a[j]%10; &#125; h=100001; while (a[h]==0) h--;//扫一遍找h h++; &#125; for (int i=2;i&lt;=n;i++) //高精度除单精度 &#123; for (int j=h-1;j&gt;=0;j--) &#123; if (a[j]%i!=0) a[j-1]+=10*(a[j]%i); a[j]=a[j]/i; &#125; &#125; h=100001; while (a[h]==0) h--;//扫一遍找h for (int i=h;i&gt;=0;i--)//输出 cout&lt;&lt;a[i];&#125; 贪心的小精灵题目描述圣诞节到了，一个小精灵想在圣诞树上拿到小礼物。圣诞树一共有$n$层高，在圣诞树的第$k$层，一共有个$k$放置礼物的礼物点，每个礼物点有对应的礼物数量。$(1&lt;=k&lt;=n)$。小精灵必须从圣诞树的最顶端(1,1)开始拿礼物，每层只能拿从一个礼物点拿对应数量的礼物。小精灵很懒，他每次只会向距离最近的礼物点前进。圣诞树上有个特殊的礼物点，那里的礼物是小精灵必须要拿到的。小精灵既想要经过特殊点，又想要在圣诞树上拿到最多的礼物，请你帮他算出他最多能拿到多少个礼物。 输入格式第1行只有一个整数$n$，表示$n$层圣诞树； 第2到$n+1$行，每层每个礼物点的礼物数量，数字之间有一个空格； 第$n+2$行有两个数$x$和$y$，表示小精灵必须要经过的礼物点，即第$x$层的第$y$个礼物点。 输出格式礼物数量总和的最大值 样例样例输入1234567573 88 1 02 7 4 44 5 2 6 52 2 样例输出128 题解两边动态规划 就是从上往下和从下往上两次DP这样求出从（1，1）到必经点的最大和必经点到底部的最大然后就AC啦 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int a[103][103],ft[103][103],fb[103][103];int main()&#123; //freopen(&quot;gift.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;gift.out&quot;,&quot;w&quot;,stdout); int n,x,y; cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; cin&gt;&gt;x&gt;&gt;y; for (int i=1;i&lt;=n;i++)//从上往下 ft[x][y]是从上往下到x,y的最大收获 for (int j=1;j&lt;=i;j++) ft[i][j]=max(ft[i-1][j],ft[i-1][j-1])+a[i][j]; for (int i=n;i&gt;=1;i--)//从下往上 fb[x][y]是从下往上到x,y的最大收获 for (int j=i;j&gt;=1;j--) fb[i][j]=max(fb[i+1][j],fb[i+1][j+1])+a[i][j]; /*这些是测试的输出 莫得感情的 for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=i;j++) cout&lt;&lt;ft[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=i;j++) cout&lt;&lt;fb[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;*/ cout&lt;&lt;ft[x][y]+fb[x][y]-a[x][y]; return 0;&#125; 取火柴游戏→题目在这← 描述和Nim的石子游戏一摸一样 只是石头变成了火柴 关于Nim游戏可以看这里 Nim游戏 就是说 对于每一种形式 都是必胜态与必败态中的一个并且每个必胜态肯定存在使情况变为必败态的移动策略而每个必败态无论如何移动都会让局面成为必胜态 这是代码↓ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n+2],tmp=0; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; tmp=tmp ^ a[i]; &#125; if (tmp==0) &#123; cout&lt;&lt;&quot;lose&quot;; return 0; &#125; int k; for (int i=1;i&lt;=n;i++) if ((a[i]^tmp)&lt;=a[i]) &#123;k=i;break;&#125; cout&lt;&lt;a[k]-(a[k]^tmp)&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl; a[k]=a[k]^tmp; for (int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; return 0;&#125; 十二号诛杀者介于懒得复制题目（太多用公式大的复制不了） 题目链接 这道题30分 使用Dijkstra最短路 代码如下 极丑无比 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;memory.h&gt;#include &lt;iomanip&gt;using namespace std;bool book[600];int main()&#123; freopen(&quot;killer.in&quot;,&quot;r&quot;,stdin); freopen(&quot;killer.out&quot;,&quot;w&quot;,stdout); int n,m,q1,q2,q3,s,u,v,w,l,r,a,b,c,d; int e[502][502]; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q1&gt;&gt;q2&gt;&gt;q3&gt;&gt;s; int f[n+3]; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) e[i][j]=2147483647; for (int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; e[u][v]=w; &#125; for (int i=1;i&lt;=q1;i++) &#123; cin&gt;&gt;u&gt;&gt;l&gt;&gt;r&gt;&gt;w; for (int j=l;j&lt;=r;j++) if (w&lt;e[u][j]) e[u][j]=w; &#125; for (int i=1;i&lt;=q2;i++) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;v&gt;&gt;w; for (int j=l;j&lt;=r;j++) if (w&lt;e[j][v]) e[j][v]=w; &#125; for (int i=1;i&lt;=q3;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;w; for (int j=a;j&lt;=b;j++) for (int k=c;k&lt;=d;k++) if (w&lt;e[j][k]) e[j][k]=w; &#125; for(int i=1;i&lt;=n;i++) e[i][i]=0; /* for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=n;j++) cout&lt;&lt;setw(9)&lt;&lt;e[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; */ int k; for (int i=1;i&lt;=n;i++) f[i]=e[s][i]; for (int i=1;i&lt;=n;i++) &#123; int mi=2147483647; for (int j=1;j&lt;=n;j++) if ((f[j]&lt;mi)&amp;&amp;(book[j]==0)) &#123; mi=f[j]; k=j; &#125; book[k]=1; //cout&lt;&lt;mi&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl; for (int j=1;j&lt;=n;j++) if (e[k][j]&lt;2147483647) if (f[j]&gt;f[k]+e[k][j]) f[j]=f[k]+e[k][j]; &#125; //for (int i=1;i&lt;=n;i++) // cout&lt;&lt;book[i]&lt;&lt;&quot; &quot;; //cout&lt;&lt;endl; for (int i=1;i&lt;=n;i++) if (f[i]==2147483647) cout&lt;&lt;-1&lt;&lt;&quot; &quot;; else cout&lt;&lt;f[i]&lt;&lt;&quot; &quot;; return 0;&#125; 坐等讲解","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://hntr.xyz/tags/%E5%85%A5%E9%97%A8/"},{"name":"高精度","slug":"高精度","permalink":"https://hntr.xyz/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hntr.xyz/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"一本通1261&1262题解","slug":"一本通1261及1262题解","date":"2019-07-09T12:27:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"一本通1261及1262题解.html","link":"","permalink":"https://hntr.xyz/%E4%B8%80%E6%9C%AC%E9%80%9A1261%E5%8F%8A1262%E9%A2%98%E8%A7%A3.html","excerpt":"题目1261原链接 【题目描述】在一个地图上有n个地窖（n≤200）,每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径，并规定路径都是单向的,且保证都是小序号地窖指向大序号地窖，也不存在可以从一个地窖出发经过若干地窖后又回到原来地窖的路径。某人可以从任意一处开始挖地雷，然后沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使他能挖到最多的地雷。","text":"题目1261原链接 【题目描述】在一个地图上有n个地窖（n≤200）,每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径，并规定路径都是单向的,且保证都是小序号地窖指向大序号地窖，也不存在可以从一个地窖出发经过若干地窖后又回到原来地窖的路径。某人可以从任意一处开始挖地雷，然后沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使他能挖到最多的地雷。 【输入】第一行：地窖的个数； 第二行：为依次每个地窖地雷的个数； 下面若干行： xi yi //表示从xi可到yi，xi&lt;yi。 最后一行为”0 0”表示结束。 【输出】k1−k2−…−kv //挖地雷的顺序 挖到最多的雷。 【输入样例】1234567891065 10 20 5 4 51 21 42 43 44 54 65 60 0 【输出样例】123-4-5-634 1261原链接 【题目描述】下图表示城市之间的交通路网，线段上的数字表示费用，单向通行由A-&gt;E。试用动态规划的最优化原理求出A-&gt;E的最省费用。 如图：求v1到v10的最短路径长度及最短路径。 【输入】第一行为城市的数量N; 后面是N*N的表示两个城市间费用组成的矩阵。 【输出】A-&gt;E的最省费用。 【输入样例】1234567891011100 2 5 1 0 0 0 0 0 00 0 0 0 12 14 0 0 0 00 0 0 0 6 10 4 0 0 00 0 0 0 13 12 11 0 0 00 0 0 0 0 0 0 3 9 00 0 0 0 0 0 0 6 5 00 0 0 0 0 0 0 0 10 00 0 0 0 0 0 0 0 0 50 0 0 0 0 0 0 0 0 20 0 0 0 0 0 0 0 0 0 【输出样例】12minlong&#x3D;191 3 5 8 10 题解两道题思路基本一致 1261设f[i]表示点i到v10的最短路径长度，则 f[10]=0f[i]=min{ a[i][x]+f[x]} 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[101][101],f[101],n,ans[101]; memset(ans,0,sizeof(ans)); cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;a[i][j]; f[i]=999999; &#125; f[n]=0; int x; //关键步骤 动态规划 for (int i=n-1;i&gt;=1;i--) for (x=i+1;x&lt;=n;x++) &#123; if ((f[x]!=999999)&amp;&amp;(a[i][x]&gt;0)&amp;&amp;(f[i]&gt;f[x]+a[i][x])) &#123; f[i]=f[x]+a[i][x];//记录权值 ans[i]=x;//记录路径 &#125; &#125; // cout&lt;&lt;&quot;minlong=&quot;&lt;&lt;f[1]&lt;&lt;endl; x=1; while(x!=0) &#123; cout&lt;&lt;x&lt;&lt;&quot; &quot;; x=ans[x]; &#125; return 0;&#125; 1262代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int w[201],f[201],c[201],n; bool a[201][201]; memset(c,0,sizeof(c)); memset(a,0,sizeof(a)); memset(f,0,sizeof(f)); cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; while(1) &#123; int ta,tb; cin&gt;&gt;ta&gt;&gt;tb; if (ta==0&amp;&amp;tb==0) break; a[ta][tb]=1; &#125; /* for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=n;j++) cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; */ int m,k; f[n]=w[n]; //关键步骤 动态规划 for (int i=n-1;i&gt;=1;i--) &#123; m=0;k=0; for (int x=i+1;x&lt;=n;x++) if ((a[i][x])&amp;&amp;(f[x]&gt;m))//求最大路径 &#123; m=f[x]; k=x; &#125; f[i]=m+w[i];//记录权值 c[i]=k;//记录路径 &#125; // k=1; for (int i=2;i&lt;=n;i++) if (f[i]&gt;f[k]) k=i; m=f[k]; cout&lt;&lt;k; k=c[k]; while(k!=0) &#123; cout&lt;&lt;&quot;-&quot;&lt;&lt;k; k=c[k]; &#125; cout&lt;&lt;endl&lt;&lt;m; return 0;&#125; \\u0056\\u0032\\u0039\\u0068\\u0064\\u0079\\u0045\\u0068\\u0035\\u0037\\u0075\\u0049\\u0035\\u004c\\u0071\\u004f\\u0035\\u006f\\u006d\\u0054\\u0035\\u0061\\u0036\\u004d\\u0035\\u005a\\u0057\\u006d\\u0037\\u0037\\u0079\\u0042\\u0037\\u0037\\u0079\\u0042\\u0037\\u0037\\u0079\\u0042","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"一本通","slug":"一本通","permalink":"https://hntr.xyz/tags/%E4%B8%80%E6%9C%AC%E9%80%9A/"}]},{"title":"一本通1259题解","slug":"一本通1259题解","date":"2019-07-05T03:25:00.000Z","updated":"2020-01-18T05:37:34.000Z","comments":true,"path":"一本通1259题解.html","link":"","permalink":"https://hntr.xyz/%E4%B8%80%E6%9C%AC%E9%80%9A1259%E9%A2%98%E8%A7%A3.html","excerpt":"**由于体验课问题，计划向后推几天😉** 题目原链接 【题目描述】设有由n(1≤n≤200)个不相同的整数组成的数列，记为:b(1)、b(2)、……、b(n)且b(i)≠b(j)(i≠j)，若存在i1&lt;i2&lt;i3&lt;…&lt;ie 且有b(i1)&lt;b(i2)&lt;…&lt;b(ie)则称为长度为e的不下降序列。程序要求，当原数列出之后，求出最长的不下降序列。 例如13，7，9，16，38，24，37，18，44，19，21，22，63，15。例中13，16，18，19，21，22，63就是一个长度为7的不下降序列，同时也有7 ，9，16，18，19，21，22，63组成的长度为8的不下降序列。","text":"**由于体验课问题，计划向后推几天😉** 题目原链接 【题目描述】设有由n(1≤n≤200)个不相同的整数组成的数列，记为:b(1)、b(2)、……、b(n)且b(i)≠b(j)(i≠j)，若存在i1&lt;i2&lt;i3&lt;…&lt;ie 且有b(i1)&lt;b(i2)&lt;…&lt;b(ie)则称为长度为e的不下降序列。程序要求，当原数列出之后，求出最长的不下降序列。 例如13，7，9，16，38，24，37，18，44，19，21，22，63，15。例中13，16，18，19，21，22，63就是一个长度为7的不下降序列，同时也有7 ，9，16，18，19，21，22，63组成的长度为8的不下降序列。 【输入】第一行为n,第二行为用空格隔开的n个整数。 【输出】第一行为输出最大个数max(形式见样例)； 第二行为max个整数形成的不下降序列,答案可能不唯一，输出一种就可以了，本题进行特殊评测。 【输入样例】121413 7 9 16 38 24 37 18 44 19 21 22 63 15 【输出样例】12max&#x3D;87 9 16 18 19 21 22 63 解题思路~第一种方法设原序列为a，则当aj&lt;ai(j&lt;i)且numj+1&gt;numi时，numi=numj+1。复杂度很明显，外层i枚举每个数，内层j枚举目前i的最优值，即O（n2）。 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a[201],i,j,num[201]; cin&gt;&gt;n; for (i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; num[i]=1; &#125; for (i=1;i&lt;=n;i++) &#123; for (j=1;j&lt;i;j++) &#123; if (a[i]&gt;=a[j]) num[i]=max(num[i],num[j]+1); &#125; &#125; int ansm=0,maxid; for (i=1;i&lt;=n;i++) if (ansm&lt;num[i]) &#123; ansm=num[i]; maxid=i; &#125; int q=0,m=ansm,c[201],k=maxid; i=maxid-1; c[q++]=maxid; while(m&gt;1) &#123; if(num[i]==m-1&amp;&amp;a[i]&lt;=a[k]) &#123; c[q++]=i; k=i; m--; &#125; i--; &#125; cout&lt;&lt;&quot;max=&quot;&lt;&lt;ansm&lt;&lt;endl; for(i=q-1;i&gt;=0;i--) printf(&quot;%d &quot;,a[c[i]]); return 0;&#125; 当然，对于n大一点的时候，会比较慢，so 暂时不会更快解决办法😓","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"一本通","slug":"一本通","permalink":"https://hntr.xyz/tags/%E4%B8%80%E6%9C%AC%E9%80%9A/"}]},{"title":"一本通1258题解","slug":"一本通1258题解","date":"2019-07-03T09:56:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"一本通1258题解.html","link":"","permalink":"https://hntr.xyz/%E4%B8%80%E6%9C%AC%E9%80%9A1258%E9%A2%98%E8%A7%A3.html","excerpt":"**由于体验课问题，计划向后推几天😉** 题目原链接 【题目描述】观察下面的数字金字塔。写一个程序查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以从当前点走到左下方的点也可以到达右下方的点。 在上面的样例中,从13到8到26到15到24的路径产生了最大的和86。","text":"**由于体验课问题，计划向后推几天😉** 题目原链接 【题目描述】观察下面的数字金字塔。写一个程序查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以从当前点走到左下方的点也可以到达右下方的点。 在上面的样例中,从13到8到26到15到24的路径产生了最大的和86。 【输入】第一个行包含R(1≤ R≤1000)，表示行的数目。 后面每行为这个数字金字塔特定行包含的整数。 所有的被供应的整数是非负的且不大于100。 【输出】单独的一行，包含那个可能得到的最大的和。 【输入样例】12345651311 812 7 266 14 15 812 7 13 24 11 【输出样例】186 解题思路深搜因为只有左右，条件便于判断，so直接尝试每种情况，通过不断的尝试得出最佳答案。 代码如下 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int a[1001][1001],ans=0,n;void dfs(int x,int y,int now)&#123; if (x==n) &#123; if (now&gt;ans) ans=now; return ; &#125; dfs(x+1,y,now+a[x+1][y]); dfs(x+1,y+1,now+a[x+1][y+1]);&#125;int main()&#123; int i,j; cin&gt;&gt;n; for (i=1;i&lt;=n;i++) for (j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; dfs(1,1,a[1][1]); cout &lt;&lt; ans; return 0;&#125; 然后见证奇迹的时刻 TLE！！！好！不亏是动态规划！ 还是太慢了 那么 优化版深搜上一个方法有严重的问题，当n比较大时会花费太多时间，因为它进行了重复的搜索。因此，我们需要重新定义递归函数dfs。定义dfs（int x，int y）表示（x，y）到终点的最大权值和，最后的答案就是dfs（1，1） 代码如下 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int a[1010][1010],book[1010][1010];int n;int dfs(int x,int y)&#123; if(book[x][y]==-1) &#123; if(x==n) book[x][y]=a[x][y]; else book[x][y]=max(dfs(x+1,y),dfs(x+1,y+1))+a[x][y]; &#125; return book[x][y];&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) &#123; cin&gt;&gt;a[i][j]; book[i][j]=-1; &#125; dfs(1,1); cout&lt;&lt;book[1][1]&lt;&lt;endl; return 0;&#125; 然后就OK了 小总结动态规划即为多阶段决策过程的最优化问题。其实就是合适的加一些条件，不断优化，每道题都有不同的优化方式，总之要因题制宜。","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"一本通","slug":"一本通","permalink":"https://hntr.xyz/tags/%E4%B8%80%E6%9C%AC%E9%80%9A/"}]},{"title":"矩阵1行列式","slug":"矩阵1行列式","date":"2019-06-25T13:59:17.000Z","updated":"2020-01-20T09:26:10.000Z","comments":true,"path":"矩阵1行列式.html","link":"","permalink":"https://hntr.xyz/%E7%9F%A9%E9%98%B51%E8%A1%8C%E5%88%97%E5%BC%8F.html","excerpt":"在一次模拟中，一道数列题目P1939矩阵加速直接30分，异常悲伤ε(┬┬﹏┬┬)3 于是乎等着老师讲了矩阵","text":"在一次模拟中，一道数列题目P1939矩阵加速直接30分，异常悲伤ε(┬┬﹏┬┬)3 于是乎等着老师讲了矩阵 先导概念：行列式~~（一大堆）数学概念行列式在数学中，是一个函数，其定义域为det的矩阵A，取值为一个标量，写作det(A)或 | A | 。无论是在线性代数、多项式理论，还是在微积分学中（比如说换元积分法中），行列式作为基本的数学工具，都有着重要的应用。行列式可以看做是有向面积或体积的概念在一般的欧几里得空间中的推广。或者说，在 n 维欧几里得空间中，行列式描述的是一个线性变换对“体积”所造成的影响。 n阶行列式的定义 n阶行列式求值过于复杂，懒得写上来😓 性质1.行列式A中某行(或列)用同一数k乘,其结果等于kA。2.行列式A等于其转置行列式AT(AT的第i行为A的第i列)。3.若n阶行列式|αij|中某行(或列);行列式则|αij|是两个行列式的和，这两个行列式的第i行(或列),一个是b1,b2,…,bn；另一个是с1，с2,…,сn；其余各行（或列）上的元与|αij|的完全一样。4.行列式A中两行（或列）互换,其结果等于-A。 ⑤把行列式A的某行（或列）中各元同乘一数后加到另一行（或列）中各对应元上，结果仍然是A。 结束~~让我们看看百度百科对于行列式的看法/滑稽 12345678910111213141516171819n阶行列式设是由排成n阶方阵形式的n²个数aij(i,j&#x3D;1,2,...,n)确定的一个数，其值为n！项之和式中k1,k2,...,kn是将序列1,2,...,n的元素次序交换k次所得到的一个序列，Σ号表示对k1,k2,...,kn取遍1,2,...,n的一切排列求和，那么数D称为n阶方阵相应的行列式.例如，四阶行列式是4！个形为的项的和，而其中a13a21a34a42相应于k&#x3D;3,即该项前端的符号应为(－1)3. 若n阶方阵A&#x3D;（aij）,则A相应的行列式D记作 D&#x3D;|A|&#x3D;detA&#x3D;det(aij) 若矩阵A相应的行列式D&#x3D;0，称A为奇异矩阵，否则称为非奇异矩阵. 标号集：序列1,2,...,n中任取k个元素i1,i2,...,ik满足 1≤i1&lt;i2&lt;...&lt;ik≤n(1) i1,i2,...,ik构成&#123;1,2,...,n&#125;的一个具有k个元素的子列，&#123;1,2,...,n&#125;的具有k个元素的满足(1)的子列的全体记作C(n,k),显然C(n,k)共有 个子列.因此C(n,k)是一个具有个元素的标号集（参见第二十一章，1，二），C(n,k)的元素记作σ,τ,...,σ∈C(n,k)表示 σ&#x3D;&#123;i1,i2,...,ik&#125; 是&#123;1,2,...,n&#125;的满足(1)的一个子列.若 令τ&#x3D;&#123;j1,j2,...,jk&#125;∈C(n,k),则σ&#x3D;τ表示i1&#x3D;j1,i2&#x3D;j2,...,ik&#x3D;jk。 坐等老师下一讲~","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"矩阵","slug":"矩阵","permalink":"https://hntr.xyz/tags/%E7%9F%A9%E9%98%B5/"},{"name":"行列式","slug":"行列式","permalink":"https://hntr.xyz/tags/%E8%A1%8C%E5%88%97%E5%BC%8F/"}]},{"title":"读书笔记-贪心算法初步学习","slug":"读书笔记-贪心算法初步学习","date":"2019-06-25T12:20:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"读书笔记-贪心算法初步学习.html","link":"","permalink":"https://hntr.xyz/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0.html","excerpt":"0622-0627读书笔记-贪心算法初步学习 活动选择问题问题描述123假设有n个活动，这些活动有起止时间，这些活动都要使用同一个如教室这样的资源。每次只能有一个活动使用该资源。我们定义两个活动起止时间不相交，则称这两个活动是相容的。求一个最大相容活动。 算法思路","text":"0622-0627读书笔记-贪心算法初步学习 活动选择问题问题描述123假设有n个活动，这些活动有起止时间，这些活动都要使用同一个如教室这样的资源。每次只能有一个活动使用该资源。我们定义两个活动起止时间不相交，则称这两个活动是相容的。求一个最大相容活动。 算法思路 12我们采取的策略是始终选取结束时间最早的活动作为我们的解集合成员。这个策略就是贪婪选择的结果。 背包问题问题描述12给定n种物品，1个背包，背包容量为c,每个物品i的价值为vi，重量为wi，如何选择装入物品能使背包的总价值最大？ 算法思路1234将物品按照单位重量价值进行排序（从大到小），将尽可能多的单位重量价值最高的物品装入背包，若将这种物品全部装入背包后，背包还有多余容量，则选择单位重量价值次高的并尽可能多地装入背包。如果最后一件物品无法全部装入，则计算可以装入的比例，然后按比例装入。 解决方案1使用结构体储存价值从高到低 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct item&#123; int weight;//物品的重量 int value;//物品的价值 float bi;//物品单位重量的价值 float rate;//使用率：1代表物品完整放入，小于1代表被分割后放入 &#125;items[100];bool cmp(const item &amp;a,const item &amp;b)&#123; return a.bi&gt;b.bi;&#125;int main()&#123; int n;//n件物品 float c;//背包容量为c cin&gt;&gt;n&gt;&gt;c; float v[n],w[n]; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;items[i].value&gt;&gt;items[i].weight; items[i].bi=items[i].value/items[i].weight; items[i].rate=0; &#125; sort(items,items+n,cmp);//排序 int sum=0,j=0; for(j=0;j&lt;n;j++)&#123; if(items[j].weight&lt;=c)&#123; items[j].rate=1; sum+=items[j].weight; c-=items[j].weight; &#125; else break; &#125; if(j&lt;n)&#123; items[j].rate=c/items[j].weight; sum+=items[j].rate*items[j].weight; &#125; return 0; &#125; 可以看到，贪心算法的思想便是去当前最好的选择，在某些情况下，这种选择出来的结果为最优解","categories":[{"name":"读书报告","slug":"读书报告","permalink":"https://hntr.xyz/categories/%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"},{"name":"《算法导论》","slug":"《算法导论》","permalink":"https://hntr.xyz/tags/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B/"}]},{"title":"一本通1320-题解","slug":"一本通1320-题解","date":"2019-06-25T02:24:38.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"一本通1320-题解.html","link":"","permalink":"https://hntr.xyz/%E4%B8%80%E6%9C%AC%E9%80%9A1320-%E9%A2%98%E8%A7%A3.html","excerpt":"有事没事来发题解~ 题目链接 【题目描述】有n堆纸牌，编号分别为 1，2，…, n。每堆上有若干张，但纸牌总数必为n的倍数。可以在任一堆上取若干张纸牌，然后移动。 移牌规则为：在编号为1的堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 n 的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。","text":"有事没事来发题解~ 题目链接 【题目描述】有n堆纸牌，编号分别为 1，2，…, n。每堆上有若干张，但纸牌总数必为n的倍数。可以在任一堆上取若干张纸牌，然后移动。 移牌规则为：在编号为1的堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 n 的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。 例如 n=4，4堆纸牌数分别为： ① 9 ② 8 ③ 17 ④ 6 移动3次可达到目的： 从 ③ 取4张牌放到④（9 8 13 10）-&gt;从③取3张牌放到 ②（9 11 10 10）-&gt; 从②取1张牌放到①（10 10 10 10）。 【输入】n（n 堆纸牌，1 ≤ n ≤ 100） a1 a2 … an （n 堆纸牌，每堆纸牌初始数，l≤ ai ≤10000）。 【输出】所有堆均达到相等时的最少移动次数。 【输入样例】1249 8 17 6 【输出样例】13 【解题思路】首先这是一道贪心题目，要的便是如何最短步数将牌均分 大致思路 找出平均求出每堆牌与平均牌的张数之差将左边的差加到右边并step+1 【代码】1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a[10000]; int sum=0,average,step=0; int i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; sum+=a[i]; &#125; average=sum/n; for(i=1;i&lt;=n;i++) a[i]-=average; for(i=1;a[i]==0&amp;&amp;i&lt;n;)i++; for(j=n;a[j]==0&amp;&amp;j&gt;1;)j--; for(;i&lt;j;) &#123; a[i+1]+=a[i]; a[i]=0; i++; step++; while(a[i]==0&amp;&amp;i&lt;j) i++; &#125; cout&lt;&lt;step&lt;&lt;endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"},{"name":"一本通","slug":"一本通","permalink":"https://hntr.xyz/tags/%E4%B8%80%E6%9C%AC%E9%80%9A/"}]},{"title":"0603-0605读书报告","slug":"0603-0605读书报告","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"0603-0605读书报告.html","link":"","permalink":"https://hntr.xyz/0603-0605%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A.html","excerpt":"学习内容：队列与链表 队列：通过数组进行队列操作，会费时间较多如图所示 每次删除会交换位置，时间较长 于是用指针（我喜欢用int）来记录队列首位末尾便可以快速完成 不多说了 链表顾名思义就是一条链子，有单向、双向、环形；","text":"学习内容：队列与链表 队列：通过数组进行队列操作，会费时间较多如图所示 每次删除会交换位置，时间较长 于是用指针（我喜欢用int）来记录队列首位末尾便可以快速完成 不多说了 链表顾名思义就是一条链子，有单向、双向、环形； 一般我会这样用 123456struct queueDat &#123; int data; queueDat *front = NULL, *back = NULL; &#125;que[100001]; 就是一个结构体，然后除了数据以外有两个指针 于是做了道题目 P1160就是一道模拟+链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;struct queueDat&#123; int ID; queueDat *front = NULL, *back = NULL;&#125; que[100001];queueDat *head = &amp;que[1];void _cut(int ID)&#123; queueDat *cut = &amp;que[ID]; if (cut-&gt;ID == head-&gt;ID) head = cut-&gt;back; cut = cut-&gt;front; cut-&gt;back = cut-&gt;back-&gt;back; cut = cut-&gt;back; cut-&gt;front = cut-&gt;front-&gt;front;&#125;void _add(int num, int ID, bool back)&#123; queueDat *find = &amp;que[ID], *add = &amp;que[num]; if (back) &#123; add-&gt;front = find; add-&gt;back = find-&gt;back; find-&gt;back = add; find = find-&gt;back-&gt;back; find-&gt;front = add; return; &#125; else &#123; add-&gt;back = find; add-&gt;front = find-&gt;front; find = find-&gt;front; find-&gt;back = add; find = find-&gt;back-&gt;back; find-&gt;front = add; if (ID == head-&gt;ID) head = add; &#125;&#125;int main()&#123; bool inQueue[100001]; memset(inQueue, false, sizeof(inQueue)); inQueue[1] = true; for (int i = 1; i &lt; 100001; i++) que[i].ID = i; que[1].back = &amp;que[1]; que[1].front = &amp;que[1]; int totStudents, a, b; cin &gt;&gt; totStudents; for (int i = 2; i &lt;= totStudents; i++) &#123; inQueue[i] = true; cin &gt;&gt; a &gt;&gt; b; _add(i, a, ((b == 0) ? false : true)); &#125; cin &gt;&gt; totStudents; for (int i = 0; i &lt; totStudents; i++) &#123; cin &gt;&gt; a; if (inQueue[a] == true) &#123; inQueue[a] = false; _cut(a); &#125; &#125; b = head-&gt;ID; do &#123; cout &lt;&lt; head-&gt;ID &lt;&lt; &quot; &quot;; head = head-&gt;back; &#125; while (b != head-&gt;ID); return 0;&#125; 指针的数据操作一般是-&gt;/‘.’ 呼~~","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://hntr.xyz/tags/%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"https://hntr.xyz/tags/%E9%93%BE%E8%A1%A8/"},{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"《啊哈！算法！》","slug":"《啊哈！算法！》","permalink":"https://hntr.xyz/tags/%E3%80%8A%E5%95%8A%E5%93%88%EF%BC%81%E7%AE%97%E6%B3%95%EF%BC%81%E3%80%8B/"}]},{"title":"P1781题解","slug":"P1781题解","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"P1781题解.html","link":"","permalink":"https://hntr.xyz/P1781%E9%A2%98%E8%A7%A3.html","excerpt":"题目链接","text":"题目链接 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int n,i,k; string max=&quot;&quot;,s; scanf(&quot;%d&quot;,&amp;n); for (i=1;i&lt;=n;i++)&#123; cin &gt;&gt; s; //直接通过比较字符串找最大值 if (s.size() &gt; max.size() || (s.size() &gt;= max.size() &amp;&amp; s &gt; max)) &#123;//先是长度 长度一直按字典序就是原本数字大小 max = s; k = i; //记录位置 &#125; &#125; cout &lt;&lt; k &lt;&lt; endl &lt;&lt; max; return 0;&#125; ps：因为不会用字符串数组，于是直接就这样找最大值了（好像更简单了） 注：C语言字符处理有待提升。","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"字符串","slug":"字符串","permalink":"https://hntr.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"一本通1178题解","slug":"一本通1178题解","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"一本通1178题解.html","link":"","permalink":"https://hntr.xyz/%E4%B8%80%E6%9C%AC%E9%80%9A1178%E9%A2%98%E8%A7%A3.html","excerpt":"上代码","text":"上代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;iostream&gt;using namespace std;struct student&#123; char name[30]; int score;&#125;;int main()&#123; int n,i,j,t; struct student stu[30]; char a[30]; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) cin &gt;&gt; stu[i].name &gt;&gt; stu[i].score; //for (i=1;i&lt;=n;i++) // cout &lt;&lt; stu[i].name &lt;&lt; &quot; &quot; &lt;&lt; stu[i].score &lt;&lt; endl; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n-1;j++) if ((stu[j].score&lt;stu[j+1].score)||( (stu[j].score==stu[j+1].score) &amp;&amp; strcmp(stu[j].name,stu[j+1].name)==1))&#123; t=stu[j].score;stu[j].score=stu[j+1].score;stu[j+1].score=t; strcpy(a,stu[j].name); strcpy(stu[j].name,stu[j+1].name); strcpy(stu[j+1].name,a); &#125; for (i=1;i&lt;=n;i++)&#123; cout &lt;&lt; stu[i].name &lt;&lt; &quot; &quot; &lt;&lt; stu[i].score &lt;&lt; endl; &#125;&#125; 用了结构去解决。。。第一次使用C语言struct 继续好好研究C语言字符串处理（比pascal烦好多啊~）","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://hntr.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"一本通","slug":"一本通","permalink":"https://hntr.xyz/tags/%E4%B8%80%E6%9C%AC%E9%80%9A/"}]},{"title":"二分小心得","slug":"二分小心得","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"二分小心得.html","link":"","permalink":"https://hntr.xyz/%E4%BA%8C%E5%88%86%E5%B0%8F%E5%BF%83%E5%BE%97.html","excerpt":"学习了二分算法，然后做了这几道题P1577SP29712401241","text":"学习了二分算法，然后做了这几道题P1577SP29712401241 然后发现基本上可以按照二分的模板去套 至于代码还是发一下 1234567891011121314151617181920212223242526272829303132333435363738394041/*1577*/#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline void read(int &amp;n)&#123; char c=getchar();bool flag=0;n=0; while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;) c==&#x27;-&#x27;?flag==1,c=getchar():c=getchar(); while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) n=n*10+c-48,c=getchar();&#125;int n,k;int a[10000001];int pd(int val)&#123; int sum=0; for(int i=1;i&lt;=n;i++) sum+=a[i]/val; return sum&gt;=k;&#125;int main()&#123; read(n); read(k); for(int i=1;i&lt;=n;i++)&#123; double p; scanf(&quot;%lf&quot;,&amp;p); a[i]=p*100; &#125; int l=0,r=100000000,ans=0; while(l&lt;=r) &#123; int mid=l+r&gt;&gt;1; if(mid==0) break; if(pd(mid)) l=mid+1,ans=mid; else r=mid-1; &#125; printf(&quot;%.2lf&quot;,(double)ans/100); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*SP297*/#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;int a[100050];int so()&#123; int n,c; scanf(&quot;%d %d&quot;,&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+1+n); int le=0,ri=a[n]; while(le&lt;=ri) &#123; int mid=(le+ri)&gt;&gt;1; int ans=1; int k=mid+a[1]; for(int i=2;i&lt;=n;i++) &#123; if(a[i]&gt;=k)&#123; ans++; k=mid+a[i]; &#125; &#125; if(ans&gt;=c) &#123; le=mid+1; &#125; else &#123; ri=mid-1; &#125; &#125; printf(&quot;%d\\n&quot;,le-1); return 0;&#125;int main()&#123; int nu; cin&gt;&gt;nu; for(int i=1;i&lt;=nu;i++) so();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*1241*/#include &lt;stdio.h&gt;double f(double x);void ok(double a, double b);int main()&#123; ok(1.5,2.4); return 0;&#125; double f(double x)&#123; return x*x*x*x*x - 15*x*x*x*x+ 85*x*x*x- 225*x*x+ 274*x - 121;&#125;void ok(double a, double b)&#123; double mid,result; mid = (a + b) / 2; result = f(mid); if(result &gt; 0.000001) &#123; ok(mid,b); &#125; else if(result &lt; -0.000001) &#123; ok(a,mid); &#125; else &#123; printf(&quot;%.6lf&quot;,mid); &#125;&#125; 总之就是二分二分再二分然后就是注意条件，一面死循环！！","categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"二分","slug":"二分","permalink":"https://hntr.xyz/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"洛谷初级字符串题解x2","slug":"洛谷初级字符串题解x2","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"洛谷初级字符串题解x2.html","link":"","permalink":"https://hntr.xyz/%E6%B4%9B%E8%B0%B7%E5%88%9D%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3x2.html","excerpt":"以下为题解x2","text":"以下为题解x2 P1553 数字反转升级版题目链接 大致过程： 代码-》 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; char p=0; int end=0; cin&gt;&gt;s; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&#x27;0&#x27;&amp;&amp;s[i]&lt;=&#x27;9&#x27;) end++; else &#123; p=s[i]; break; &#125; &#125; int x=end; end--; while(s[end]==&#x27;0&#x27;&amp;&amp;end&gt;0) end--; for(int i=end;i&gt;=0;i--) cout&lt;&lt;s[i]; if(p==0) return 0;//如果~~~就退出了 else if(p==&#x27;%&#x27;) &#123;cout&lt;&lt;p;return 0;&#125; else cout&lt;&lt;p; int m=s.size()-1; while(s[x+1]==&#x27;0&#x27;&amp;&amp;x&lt;m-1) x++; while(s[m]==&#x27;0&#x27;&amp;&amp;m&gt;x+1) m--; for(int i=m;i&gt;x;i--) cout&lt;&lt;s[i]; return 0;&#125; P1200just判断一下 代码 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std ;string a , b ;int ans = 1 , num = 1 ;main()&#123; cin &gt;&gt;a&gt;&gt;b; for( int i = 0 ; i &lt; a.length() ; i ++ ) ans *= a[i] - 64; for( int i = 0 ; i &lt; b.length() ; i ++ ) num *= b[i] - 64; ans %= 47 , num %= 47 ; if( ans == num ) cout &lt;&lt; &quot;GO&quot; ; else cout &lt;&lt; &quot;STAY&quot; ; return 0 ;&#125; 注意点：一直乘过去的话，初始化要成1；如果是0就会一直是0（调试许久） And 似乎字符串有两类（我知道的）处理方法欸，有种就是char s[]然后strlen(s);之类的 ；还有一种就是用string 然后 s.length()之类的。 So 我改用那种比较好呢？ 注：之所以今天才发是因为markdown 编辑器坏了，so今天才发，（话说这两天github下载怎么这么慢啊！！！！！！）","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"字符串","slug":"字符串","permalink":"https://hntr.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"读书报告《啊哈！算法！》第4章","slug":"读书报告《啊哈！算法！》第4章","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"读书报告《啊哈！算法！》第4章.html","link":"","permalink":"https://hntr.xyz/%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A%E3%80%8A%E5%95%8A%E5%93%88%EF%BC%81%E7%AE%97%E6%B3%95%EF%BC%81%E3%80%8B%E7%AC%AC4%E7%AB%A0.html","excerpt":"如题，这是一篇读书报告》.《 首先，我了解到深搜和广搜两种算法，有什么不同之处呢? 深搜从某条路一直走到底撞到边界条件再回头，尝试其他可能 有道题目： P1036 通过深搜实现","text":"如题，这是一篇读书报告》.《 首先，我了解到深搜和广搜两种算法，有什么不同之处呢? 深搜从某条路一直走到底撞到边界条件再回头，尝试其他可能 有道题目： P1036 通过深搜实现 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int a[10001];int n,k,sum,total;inline void print()&#123; printf(&quot;%d&quot;,total);&#125;inline bool prime(int x)&#123; for(register int i=2; i&lt;=sqrt(x); i++) if(x%i==0) return false; return true;&#125;inline void dfs(int step,int sum,int cnt)&#123; if(step==n+1||cnt==k) &#123; if(prime(sum) &amp;&amp; cnt==k) total++; return; &#125; dfs(step+1,sum+a[step],cnt+1); dfs(step+1,sum,cnt); return;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(register int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs(1,0,0); print(); return 0;&#125; 上题中即使用了深搜总结：深搜重要之处在于边界条件 十分重要~~！！！ 不然会死循环或者浪费时间等一大堆事 广搜：层层递进对＜（＾－＾）＞特点就是层层递进 在走迷宫这道题目中 广搜就像这样↓ 层层递进 使用两个坐标的队列以及一个step的队列记录，同时在每个节点进行扩展 总结：好好利用搜索可以解决很多循环无法解决的问题，但边界条件要设置好，以及每次调用函数时的数据要对应。","categories":[{"name":"读书报告","slug":"读书报告","permalink":"https://hntr.xyz/categories/%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"《啊哈！算法！》","slug":"《啊哈！算法！》","permalink":"https://hntr.xyz/tags/%E3%80%8A%E5%95%8A%E5%93%88%EF%BC%81%E7%AE%97%E6%B3%95%EF%BC%81%E3%80%8B/"},{"name":"搜索","slug":"搜索","permalink":"https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"过程函数与递归-题解","slug":"过程函数与递归-题解","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-07T11:52:18.000Z","comments":true,"path":"过程函数与递归-题解.html","link":"","permalink":"https://hntr.xyz/%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E9%80%92%E5%BD%92-%E9%A2%98%E8%A7%A3.html","excerpt":"","text":"P1036 通过深搜实现 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;aint a[10001];int n,k,sum,total;inline void print()&#123; printf(&quot;%d&quot;,total);&#125;inline bool prime(int x)&#123; for(register int i=2; i&lt;=sqrt(x); i++) if(x%i==0) return false; return true;&#125;inline void dfs(int step,int sum,int cnt)&#123; if(step==n+1||cnt==k) &#123; if(prime(sum) &amp;&amp; cnt==k) total++; return; &#125; dfs(step+1,sum+a[step],cnt+1); dfs(step+1,sum,cnt); return;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(register int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs(1,0,0); print(); return 0;&#125; P11491234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;int nu[10]= &#123;6,2,5,5,4,5,6,3,7,6&#125;;int matches(int num)&#123; int i,k=0; for(i=num; i!=0; i/=10) k+=nu[i%10]; if(num==0) k+=nu[0]; return k;&#125;int answer(int n)&#123; int i,j,all=0; //cin&gt;&gt;n; for(i=0; i&lt;=1000; i++) for(j=0; j&lt;=1000; j++) if(matches(i)+matches(j)+matches(i+j)+4==n) all++; //cout&lt;&lt;all; return all;&#125;/*int main()&#123; int i; for(i=1;i&lt;=1000;i++) cout&lt;&lt;answer(i)&lt;&lt;&quot;,&quot;;&#125;*/int main()&#123; int n,a[1010]=&#123;0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,8,9,6,9,29,39,38,65,88,128,192,319,454,624,864, 1262,1670,2256,2889,4008,5174,7146,9680,13395,17912,23707,30003,37134,44686,52624,60770, 67263,72329,75051,75184,72263,68599,62046,53310,43779,33711,23939,15912,10004,5645,3133, 1428,769,236,164,14,28,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&#125;; cin&gt;&gt;n; cout&lt;&lt;a[n];&#125; 注：重点在与answer这个函数，通过比对得出答案 因为害怕时间不够使用了打表（事实证明不需这样就够了）","categories":[{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"过程","slug":"过程","permalink":"https://hntr.xyz/tags/%E8%BF%87%E7%A8%8B/"},{"name":"递归","slug":"递归","permalink":"https://hntr.xyz/tags/%E9%80%92%E5%BD%92/"}]}],"categories":[{"name":"算法学习","slug":"算法学习","permalink":"https://hntr.xyz/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"题解","slug":"题解","permalink":"https://hntr.xyz/categories/%E9%A2%98%E8%A7%A3/"},{"name":"读书报告","slug":"读书报告","permalink":"https://hntr.xyz/categories/%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"树","slug":"树","permalink":"https://hntr.xyz/tags/%E6%A0%91/"},{"name":"珂朵莉","slug":"珂朵莉","permalink":"https://hntr.xyz/tags/%E7%8F%82%E6%9C%B5%E8%8E%89/"},{"name":"luogu","slug":"luogu","permalink":"https://hntr.xyz/tags/luogu/"},{"name":"莫队","slug":"莫队","permalink":"https://hntr.xyz/tags/%E8%8E%AB%E9%98%9F/"},{"name":"倍增","slug":"倍增","permalink":"https://hntr.xyz/tags/%E5%80%8D%E5%A2%9E/"},{"name":"双向链表","slug":"双向链表","permalink":"https://hntr.xyz/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"https://hntr.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"并查集","slug":"并查集","permalink":"https://hntr.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"NOIP","slug":"NOIP","permalink":"https://hntr.xyz/tags/NOIP/"},{"name":"DP","slug":"DP","permalink":"https://hntr.xyz/tags/DP/"},{"name":"shu数论","slug":"shu数论","permalink":"https://hntr.xyz/tags/shu%E6%95%B0%E8%AE%BA/"},{"name":"贪心","slug":"贪心","permalink":"https://hntr.xyz/tags/%E8%B4%AA%E5%BF%83/"},{"name":"模拟","slug":"模拟","permalink":"https://hntr.xyz/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"CSP","slug":"CSP","permalink":"https://hntr.xyz/tags/CSP/"},{"name":"栈","slug":"栈","permalink":"https://hntr.xyz/tags/%E6%A0%88/"},{"name":"STL","slug":"STL","permalink":"https://hntr.xyz/tags/STL/"},{"name":"set","slug":"set","permalink":"https://hntr.xyz/tags/set/"},{"name":"LCA","slug":"LCA","permalink":"https://hntr.xyz/tags/LCA/"},{"name":"ST表","slug":"ST表","permalink":"https://hntr.xyz/tags/ST%E8%A1%A8/"},{"name":"线段树","slug":"线段树","permalink":"https://hntr.xyz/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","permalink":"https://hntr.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"搜索","slug":"搜索","permalink":"https://hntr.xyz/tags/%E6%90%9C%E7%B4%A2/"},{"name":"BFS","slug":"BFS","permalink":"https://hntr.xyz/tags/BFS/"},{"name":"POJ","slug":"POJ","permalink":"https://hntr.xyz/tags/POJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://hntr.xyz/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"Prim","slug":"Prim","permalink":"https://hntr.xyz/tags/Prim/"},{"name":"HDU","slug":"HDU","permalink":"https://hntr.xyz/tags/HDU/"},{"name":"DFS","slug":"DFS","permalink":"https://hntr.xyz/tags/DFS/"},{"name":"堆","slug":"堆","permalink":"https://hntr.xyz/tags/%E5%A0%86/"},{"name":"入门","slug":"入门","permalink":"https://hntr.xyz/tags/%E5%85%A5%E9%97%A8/"},{"name":"高精度","slug":"高精度","permalink":"https://hntr.xyz/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hntr.xyz/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"一本通","slug":"一本通","permalink":"https://hntr.xyz/tags/%E4%B8%80%E6%9C%AC%E9%80%9A/"},{"name":"矩阵","slug":"矩阵","permalink":"https://hntr.xyz/tags/%E7%9F%A9%E9%98%B5/"},{"name":"行列式","slug":"行列式","permalink":"https://hntr.xyz/tags/%E8%A1%8C%E5%88%97%E5%BC%8F/"},{"name":"《算法导论》","slug":"《算法导论》","permalink":"https://hntr.xyz/tags/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B/"},{"name":"队列","slug":"队列","permalink":"https://hntr.xyz/tags/%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"https://hntr.xyz/tags/%E9%93%BE%E8%A1%A8/"},{"name":"《啊哈！算法！》","slug":"《啊哈！算法！》","permalink":"https://hntr.xyz/tags/%E3%80%8A%E5%95%8A%E5%93%88%EF%BC%81%E7%AE%97%E6%B3%95%EF%BC%81%E3%80%8B/"},{"name":"字符串","slug":"字符串","permalink":"https://hntr.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二分","slug":"二分","permalink":"https://hntr.xyz/tags/%E4%BA%8C%E5%88%86/"},{"name":"过程","slug":"过程","permalink":"https://hntr.xyz/tags/%E8%BF%87%E7%A8%8B/"},{"name":"递归","slug":"递归","permalink":"https://hntr.xyz/tags/%E9%80%92%E5%BD%92/"}]}